{
    "sourceFile": "lib/features/connection/screens/notifications_screen.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 20,
            "patches": [
                {
                    "date": 1742921167428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1742921381240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n import 'package:flutter/material.dart';\r\n import 'package:aybudle/core/services/api_service.dart';\r\n+import 'package:flutter_html/flutter_html.dart';\r\n \r\n class NotificationsScreen extends StatefulWidget {\r\n   final String baseUrl;\r\n   final String token;\r\n@@ -44,16 +45,17 @@\n \r\n   Widget _buildNotificationItem(Map<String, dynamic> notification) {\r\n     return ListTile(\r\n       title: Text(notification['subject'] ?? 'No Subject'),\r\n-      subtitle: Text(notification['smallmessage'] ?? 'No message'),\r\n+      subtitle: Html(data: notification['smallmessage'] ?? ''),\r\n       trailing: notification['timecreated'] != null\r\n           ? Text(DateTime.fromMillisecondsSinceEpoch(\r\n                   notification['timecreated'] * 1000)\r\n               .toString()\r\n               .split(' ')\r\n               .first)\r\n           : const Text(''),\r\n+      isThreeLine: true,\r\n     );\r\n   }\r\n \r\n   @override\r\n"
                },
                {
                    "date": 1742922012336,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n import 'package:flutter/material.dart';\r\n import 'package:aybudle/core/services/api_service.dart';\r\n-import 'package:flutter_html/flutter_html.dart';\r\n \r\n class NotificationsScreen extends StatefulWidget {\r\n   final String baseUrl;\r\n   final String token;\r\n@@ -28,34 +27,62 @@\n   }\r\n \r\n   Future<void> _fetchNotifications() async {\r\n     try {\r\n+      print('=== Starting notifications fetch ===');\r\n+      print('Base URL: ${widget.baseUrl}');\r\n+      print('Token: ${widget.token}');\r\n+\r\n+      // Get user info\r\n+      print('\\n=== Fetching user info ===');\r\n       final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n+      print('Raw user info response:');\r\n+      print(userInfo);\r\n+      \r\n       final userId = userInfo['userid'] as int;\r\n+      print('Extracted user ID: $userId');\r\n+\r\n+      // Get notifications\r\n+      print('\\n=== Fetching notifications ===');\r\n       final notifications = await _apiService.getNotifications(widget.baseUrl, widget.token, userId);\r\n+      print('Raw notifications response:');\r\n+      print(notifications);\r\n \r\n       setState(() {\r\n         _notifications = notifications;\r\n         _isLoading = false;\r\n       });\r\n+\r\n+      print('\\n=== Final notifications data ===');\r\n+      print('Number of notifications: ${_notifications.length}');\r\n+      if (_notifications.isNotEmpty) {\r\n+        print('First notification:');\r\n+        print(_notifications.first);\r\n+      }\r\n     } catch (e) {\r\n-      print('Error fetching notifications: $e');\r\n+      print('\\n=== Error occurred ===');\r\n+      print('Error type: ${e.runtimeType}');\r\n+      print('Error message: $e');\r\n+      if (e is DioException) {\r\n+        print('Dio error details:');\r\n+        print('Response data: ${e.response?.data}');\r\n+        print('Status code: ${e.response?.statusCode}');\r\n+      }\r\n       setState(() => _isLoading = false);\r\n     }\r\n   }\r\n \r\n   Widget _buildNotificationItem(Map<String, dynamic> notification) {\r\n     return ListTile(\r\n       title: Text(notification['subject'] ?? 'No Subject'),\r\n-      subtitle: Html(data: notification['smallmessage'] ?? ''),\r\n+      subtitle: Text(notification['smallmessage'] ?? 'No message'),\r\n       trailing: notification['timecreated'] != null\r\n           ? Text(DateTime.fromMillisecondsSinceEpoch(\r\n                   notification['timecreated'] * 1000)\r\n               .toString()\r\n               .split(' ')\r\n               .first)\r\n           : const Text(''),\r\n-      isThreeLine: true,\r\n     );\r\n   }\r\n \r\n   @override\r\n"
                },
                {
                    "date": 1742922050003,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+import 'package:dio/dio.dart';\r\n import 'package:flutter/material.dart';\r\n import 'package:aybudle/core/services/api_service.dart';\r\n \r\n class NotificationsScreen extends StatefulWidget {\r\n"
                },
                {
                    "date": 1742996254190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,79 @@\n+import 'package:dio/dio.dart';\r\n+import 'package:flutter/material.dart';\r\n+import 'package:aybudle/core/services/api_service.dart';\r\n+\r\n+class NotificationsScreen extends StatefulWidget {\r\n+  final String baseUrl;\r\n+  final String token;\r\n+\r\n+  const NotificationsScreen({\r\n+    Key? key,\r\n+    required this.baseUrl,\r\n+    required this.token,\r\n+  }) : super(key: key);\r\n+\r\n+  @override\r\n+  State<NotificationsScreen> createState() => _NotificationsScreenState();\r\n+}\r\n+\r\n+class _NotificationsScreenState extends State<NotificationsScreen> {\r\n+  bool _isLoading = true;\r\n+  List<dynamic> _notifications = [];\r\n+  final ApiService _apiService = ApiService();\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    _fetchNotifications();\r\n+  }\r\n+\r\n+  Future<void> _fetchNotifications() async {\r\n+    try {\r\n+      final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n+      final userId = userInfo['userid'] as int;\r\n+      final notifications = await _apiService.getNotifications(widget.baseUrl, widget.token, userId);\r\n+  \r\n+      setState(() {\r\n+        _notifications = notifications;\r\n+        _isLoading = false;\r\n+      });\r\n+    } catch (e) {\r\n+      if (e is DioException) {\r\n+        print('Dio error details:');\r\n+        print('Response data: ${e.response?.data}');\r\n+        print('Status code: ${e.response?.statusCode}');\r\n+      }\r\n+      setState(() => _isLoading = false);\r\n+    }\r\n+  }\r\n+\r\n+  Widget _buildNotificationItem(Map<String, dynamic> notification) {\r\n+    return ListTile(\r\n+      title: Text(notification['subject'] ?? 'No Subject'),\r\n+      subtitle: Text(notification['smallmessage'] ?? 'No message'),\r\n+      trailing: notification['timecreated'] != null\r\n+          ? Text(DateTime.fromMillisecondsSinceEpoch(\r\n+                  notification['timecreated'] * 1000)\r\n+              .toString()\r\n+              .split(' ')\r\n+              .first)\r\n+          : const Text(''),\r\n+    );\r\n+  }\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return Scaffold(\r\n+      appBar: AppBar(title: const Text('Notifications')),\r\n+      body: _isLoading\r\n+          ? const Center(child: CircularProgressIndicator())\r\n+          : _notifications.isEmpty\r\n+              ? const Center(child: Text('No notifications found.'))\r\n+              : ListView.builder(\r\n+                  itemCount: _notifications.length,\r\n+                  itemBuilder: (context, index) =>\r\n+                      _buildNotificationItem(_notifications[index]),\r\n+                ),\r\n+    );\r\n+  }\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1742998312163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,87 +28,8 @@\n   }\r\n \r\n   Future<void> _fetchNotifications() async {\r\n     try {\r\n-      final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n-      final userId = userInfo['userid'] as int;\r\n-      final notifications = await _apiService.getNotifications(widget.baseUrl, widget.token, userId);\r\n-  \r\n-      setState(() {\r\n-        _notifications = notifications;\r\n-        _isLoading = false;\r\n-      });\r\n-    } catch (e) {\r\n-      if (e is DioException) {\r\n-        print('Dio error details:');\r\n-        print('Response data: ${e.response?.data}');\r\n-        print('Status code: ${e.response?.statusCode}');\r\n-      }\r\n-      setState(() => _isLoading = false);\r\n-    }\r\n-  }\r\n-\r\n-  Widget _buildNotificationItem(Map<String, dynamic> notification) {\r\n-    return ListTile(\r\n-      title: Text(notification['subject'] ?? 'No Subject'),\r\n-      subtitle: Text(notification['smallmessage'] ?? 'No message'),\r\n-      trailing: notification['timecreated'] != null\r\n-          ? Text(DateTime.fromMillisecondsSinceEpoch(\r\n-                  notification['timecreated'] * 1000)\r\n-              .toString()\r\n-              .split(' ')\r\n-              .first)\r\n-          : const Text(''),\r\n-    );\r\n-  }\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    return Scaffold(\r\n-      appBar: AppBar(title: const Text('Notifications')),\r\n-      body: _isLoading\r\n-          ? const Center(child: CircularProgressIndicator())\r\n-          : _notifications.isEmpty\r\n-              ? const Center(child: Text('No notifications found.'))\r\n-              : ListView.builder(\r\n-                  itemCount: _notifications.length,\r\n-                  itemBuilder: (context, index) =>\r\n-                      _buildNotificationItem(_notifications[index]),\r\n-                ),\r\n-    );\r\n-  }\r\n-}\n-import 'package:dio/dio.dart';\r\n-import 'package:flutter/material.dart';\r\n-import 'package:aybudle/core/services/api_service.dart';\r\n-\r\n-class NotificationsScreen extends StatefulWidget {\r\n-  final String baseUrl;\r\n-  final String token;\r\n-\r\n-  const NotificationsScreen({\r\n-    Key? key,\r\n-    required this.baseUrl,\r\n-    required this.token,\r\n-  }) : super(key: key);\r\n-\r\n-  @override\r\n-  State<NotificationsScreen> createState() => _NotificationsScreenState();\r\n-}\r\n-\r\n-class _NotificationsScreenState extends State<NotificationsScreen> {\r\n-  bool _isLoading = true;\r\n-  List<dynamic> _notifications = [];\r\n-  final ApiService _apiService = ApiService();\r\n-\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    _fetchNotifications();\r\n-  }\r\n-\r\n-  Future<void> _fetchNotifications() async {\r\n-    try {\r\n       print('=== Starting notifications fetch ===');\r\n       print('Base URL: ${widget.baseUrl}');\r\n       print('Token: ${widget.token}');\r\n \r\n"
                },
                {
                    "date": 1744385326290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,9 @@\n import 'package:dio/dio.dart';\r\n import 'package:flutter/material.dart';\r\n import 'package:aybudle/core/services/api_service.dart';\r\n+import 'dart:developer' as developer; // Use aliased developer log\r\n+import 'package:flutter_html/flutter_html.dart'; // Add flutter_html package: flutter pub add flutter_html\r\n \r\n class NotificationsScreen extends StatefulWidget {\r\n   final String baseUrl;\r\n   final String token;\r\n@@ -17,88 +19,349 @@\n }\r\n \r\n class _NotificationsScreenState extends State<NotificationsScreen> {\r\n   bool _isLoading = true;\r\n-  List<dynamic> _notifications = [];\r\n+  // Store the full response map initially, or just the list if preferred\r\n+  List<Map<String, dynamic>> _notifications = [];\r\n+  int _unreadCount = 0; // Keep track of unread count\r\n+  String? _error; // Store potential error messages\r\n   final ApiService _apiService = ApiService();\r\n+  int? _userId; // Store user ID after fetching\r\n \r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n-    _fetchNotifications();\r\n+    _fetchInitialData();\r\n   }\r\n \r\n+  Future<void> _fetchInitialData() async {\r\n+    // First, get the user ID if not already fetched elsewhere\r\n+    // In a real app, you might get this once after login and store it in a provider/state management solution\r\n+    if (_userId == null) {\r\n+       try {\r\n+          developer.log('Fetching user info for notifications...', name: 'NotificationsScreen');\r\n+          final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n+          // Defensive check for userid existence and type\r\n+          if (userInfo.containsKey('userid') && userInfo['userid'] is int) {\r\n+             _userId = userInfo['userid'] as int;\r\n+             developer.log('User ID obtained: $_userId', name: 'NotificationsScreen');\r\n+             await _fetchNotifications(); // Now fetch notifications\r\n+          } else {\r\n+             developer.log('User ID not found or invalid type in user info response: $userInfo', name: 'NotificationsScreen', level: 1000); // Log as error\r\n+             setState(() {\r\n+               _isLoading = false;\r\n+               _error = 'Could not retrieve user information.';\r\n+             });\r\n+          }\r\n+       } catch (e, s) {\r\n+          developer.log('Error fetching user info: $e', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n+          setState(() {\r\n+            _isLoading = false;\r\n+            _error = 'Error getting user info: ${e.toString()}';\r\n+          });\r\n+       }\r\n+    } else {\r\n+       await _fetchNotifications(); // User ID already available\r\n+    }\r\n+  }\r\n+\r\n+\r\n   Future<void> _fetchNotifications() async {\r\n+    if (_userId == null) {\r\n+       developer.log('Cannot fetch notifications: User ID is null.', name: 'NotificationsScreen', level: 1000);\r\n+       setState(() {\r\n+         _isLoading = false;\r\n+         _error = 'User ID not available.';\r\n+       });\r\n+       return;\r\n+    }\r\n+\r\n+    setState(() {\r\n+      _isLoading = true;\r\n+      _error = null; // Clear previous errors\r\n+    });\r\n+\r\n     try {\r\n-      print('=== Starting notifications fetch ===');\r\n-      print('Base URL: ${widget.baseUrl}');\r\n-      print('Token: ${widget.token}');\r\n+      developer.log('=== Starting notifications fetch ===', name: 'NotificationsScreen');\r\n+      developer.log('Base URL: ${widget.baseUrl}', name: 'NotificationsScreen');\r\n+      // Avoid logging token in production\r\n+      // developer.log('Token: ${widget.token}', name: 'NotificationsScreen');\r\n+      developer.log('User ID: $_userId', name: 'NotificationsScreen');\r\n \r\n-      // Get user info\r\n-      print('\\n=== Fetching user info ===');\r\n-      final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n-      print('Raw user info response:');\r\n-      print(userInfo);\r\n-      \r\n-      final userId = userInfo['userid'] as int;\r\n-      print('Extracted user ID: $userId');\r\n+      // Get notifications response (expecting a Map)\r\n+      final notificationsResponse = await _apiService.getNotifications(widget.baseUrl, widget.token, _userId!);\r\n+      developer.log('Raw notifications response map:', name: 'NotificationsScreen');\r\n+      developer.log(notificationsResponse.toString(), name: 'NotificationsScreen');\r\n \r\n-      // Get notifications\r\n-      print('\\n=== Fetching notifications ===');\r\n-      final notifications = await _apiService.getNotifications(widget.baseUrl, widget.token, userId);\r\n-      print('Raw notifications response:');\r\n-      print(notifications);\r\n+      // Extract the list and unread count\r\n+      final List<dynamic> notificationsList = notificationsResponse['notifications'] as List<dynamic>? ?? [];\r\n+      final int unreadCount = notificationsResponse['unreadcount'] as int? ?? 0;\r\n \r\n+       // Ensure all items in the list are Maps\r\n+      final List<Map<String, dynamic>> typedNotifications = notificationsList\r\n+          .whereType<Map<String, dynamic>>() // Filter out non-map items if any\r\n+          .toList();\r\n+\r\n       setState(() {\r\n-        _notifications = notifications;\r\n+        _notifications = typedNotifications;\r\n+        _unreadCount = unreadCount; // Update unread count\r\n         _isLoading = false;\r\n       });\r\n \r\n-      print('\\n=== Final notifications data ===');\r\n-      print('Number of notifications: ${_notifications.length}');\r\n+      developer.log('\\n=== Processed notifications data ===', name: 'NotificationsScreen');\r\n+      developer.log('Number of notifications: ${_notifications.length}', name: 'NotificationsScreen');\r\n+      developer.log('Reported unread count: $_unreadCount', name: 'NotificationsScreen');\r\n       if (_notifications.isNotEmpty) {\r\n-        print('First notification:');\r\n-        print(_notifications.first);\r\n+        developer.log('First notification details:', name: 'NotificationsScreen');\r\n+        developer.log(_notifications.first.toString(), name: 'NotificationsScreen');\r\n       }\r\n-    } catch (e) {\r\n-      print('\\n=== Error occurred ===');\r\n-      print('Error type: ${e.runtimeType}');\r\n-      print('Error message: $e');\r\n+    } catch (e, s) {\r\n+      developer.log('\\n=== Error occurred fetching notifications ===', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n       if (e is DioException) {\r\n-        print('Dio error details:');\r\n-        print('Response data: ${e.response?.data}');\r\n-        print('Status code: ${e.response?.statusCode}');\r\n+        developer.log('Dio error details:', name: 'NotificationsScreen', level: 1000);\r\n+        developer.log('Response data: ${e.response?.data}', name: 'NotificationsScreen', level: 1000);\r\n+        developer.log('Status code: ${e.response?.statusCode}', name: 'NotificationsScreen', level: 1000);\r\n       }\r\n-      setState(() => _isLoading = false);\r\n+      setState(() {\r\n+         _isLoading = false;\r\n+         _error = e.toString(); // Display error message\r\n+      });\r\n     }\r\n   }\r\n \r\n-  Widget _buildNotificationItem(Map<String, dynamic> notification) {\r\n+  // Function to mark a notification as read\r\n+  Future<void> _markAsRead(int notificationId, int index) async {\r\n+    // Optimistically update the UI first\r\n+    setState(() {\r\n+      // Find the notification and update its timeread locally\r\n+      // Create a mutable copy if needed\r\n+      // Note: This assumes 'timeread' is the field indicating read status. Adjust if needed.\r\n+       var updatedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n+       if (updatedNotification['timeread'] == null) {\r\n+          updatedNotification['timeread'] = DateTime.now().millisecondsSinceEpoch ~/ 1000;\r\n+          _notifications[index] = updatedNotification;\r\n+          _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length); // Decrement unread count\r\n+       }\r\n+    });\r\n+\r\n+    // Call the API to mark as read\r\n+    bool success = await _apiService.markNotificationRead(widget.baseUrl, widget.token, notificationId);\r\n+\r\n+    if (!success) {\r\n+      developer.log('Failed to mark notification $notificationId as read on server.', name: 'NotificationsScreen', level: 900); // Log as warning\r\n+      // Optionally revert the UI change or show a snackbar\r\n+       ScaffoldMessenger.of(context).showSnackBar(\r\n+          const SnackBar(content: Text('Could not mark notification as read on server.')),\r\n+       );\r\n+       // Revert UI change (optional, might cause flicker)\r\n+       /* setState(() {\r\n+          var revertedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n+           if (revertedNotification['timeread'] != null) { // Check if it was actually changed\r\n+              revertedNotification['timeread'] = null;\r\n+              _notifications[index] = revertedNotification;\r\n+              _unreadCount++; // Increment back\r\n+           }\r\n+       }); */\r\n+       // Or just refresh the list entirely to get the true state\r\n+       // await _fetchNotifications();\r\n+    } else {\r\n+       developer.log('Successfully marked notification $notificationId as read on server.', name: 'NotificationsScreen');\r\n+       // UI is already updated, maybe refresh the count from API if needed\r\n+    }\r\n+  }\r\n+\r\n+  // Helper to format the date/time nicely\r\n+  String _formatDateTime(int timestamp) {\r\n+    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);\r\n+    final now = DateTime.now();\r\n+    final difference = now.difference(dateTime);\r\n+\r\n+    if (difference.inSeconds < 60) {\r\n+      return '${difference.inSeconds}s ago';\r\n+    } else if (difference.inMinutes < 60) {\r\n+      return '${difference.inMinutes}m ago';\r\n+    } else if (difference.inHours < 24) {\r\n+      return '${difference.inHours}h ago';\r\n+    } else if (difference.inDays < 7) {\r\n+      return '${difference.inDays}d ago';\r\n+    } else {\r\n+      // Consider using intl package for better date formatting\r\n+      return '${dateTime.day}/${dateTime.month}/${dateTime.year}';\r\n+    }\r\n+  }\r\n+\r\n+  Widget _buildNotificationItem(Map<String, dynamic> notification, int index) {\r\n+    final bool isRead = notification['timeread'] != null;\r\n+    final int timeCreated = notification['timecreated'] as int? ?? 0;\r\n+    final String subject = notification['subject'] as String? ?? 'No Subject';\r\n+    final String smallMessage = notification['smallmessage'] as String? ?? ''; // Usually plain text\r\n+    // final String fullMessage = notification['fullmessage'] as String? ?? ''; // Often HTML\r\n+    // final int fullMessageFormat = notification['fullmessageformat'] as int? ?? 0; // 1=HTML, 0=Markdown, 2=Plain, 4=Legacy Moodle Auto\r\n+\r\n     return ListTile(\r\n-      title: Text(notification['subject'] ?? 'No Subject'),\r\n-      subtitle: Text(notification['smallmessage'] ?? 'No message'),\r\n-      trailing: notification['timecreated'] != null\r\n-          ? Text(DateTime.fromMillisecondsSinceEpoch(\r\n-                  notification['timecreated'] * 1000)\r\n-              .toString()\r\n-              .split(' ')\r\n-              .first)\r\n-          : const Text(''),\r\n+      // Leading icon changes based on read status\r\n+      leading: Icon(\r\n+        isRead ? Icons.notifications_none : Icons.notifications_active,\r\n+        color: isRead ? Colors.grey : Theme.of(context).colorScheme.primary,\r\n+      ),\r\n+      // Title is bolder if unread\r\n+      title: Text(\r\n+        subject,\r\n+        style: TextStyle(\r\n+          fontWeight: isRead ? FontWeight.normal : FontWeight.bold,\r\n+        ),\r\n+      ),\r\n+      // Use small message as subtitle\r\n+      subtitle: Text(\r\n+          smallMessage,\r\n+          maxLines: 2,\r\n+          overflow: TextOverflow.ellipsis,\r\n+      ),\r\n+      // Show relative time\r\n+      trailing: timeCreated > 0\r\n+          ? Text(\r\n+               _formatDateTime(timeCreated),\r\n+               style: TextStyle(fontSize: 12, color: Colors.grey[600]),\r\n+            )\r\n+          : null,\r\n+      isThreeLine: smallMessage.isNotEmpty, // Allow more space if subtitle exists\r\n+      onTap: () {\r\n+        developer.log('Tapped notification ID: ${notification['id']}', name: 'NotificationsScreen');\r\n+\r\n+        // --- Show details in a dialog/bottom sheet ---\r\n+         showModalBottomSheet(\r\n+             context: context,\r\n+             isScrollControlled: true, // Allow full height\r\n+             builder: (context) => DraggableScrollableSheet(\r\n+                  initialChildSize: 0.6, // Start at 60% height\r\n+                  minChildSize: 0.3,\r\n+                  maxChildSize: 0.9, // Allow almost full height\r\n+                  expand: false,\r\n+                  builder: (_, scrollController) => Container(\r\n+                       padding: const EdgeInsets.all(16.0),\r\n+                       child: ListView( // Use ListView for scrolling long content\r\n+                           controller: scrollController,\r\n+                           children: [\r\n+                               Text(\r\n+                                   subject,\r\n+                                   style: Theme.of(context).textTheme.headlineSmall?.copyWith(\r\n+                                        fontWeight: isRead ? FontWeight.normal : FontWeight.bold,\r\n+                                   )\r\n+                               ),\r\n+                               const SizedBox(height: 8),\r\n+                               if (timeCreated > 0)\r\n+                                  Text(\r\n+                                      'Received: ${_formatDateTime(timeCreated)}',\r\n+                                      style: TextStyle(fontSize: 12, color: Colors.grey[700]),\r\n+                                  ),\r\n+                               const Divider(height: 24),\r\n+                               // Render HTML content safely\r\n+                               if (notification['fullmessage'] != null)\r\n+                                  Html(data: notification['fullmessage'] as String)\r\n+                               else\r\n+                                  Text(smallMessage), // Fallback to small message\r\n+                               const SizedBox(height: 20),\r\n+                               // Optionally add context link button\r\n+                               if (notification['contexturl'] != null && notification['contexturlname'] != null)\r\n+                                  ElevatedButton.icon(\r\n+                                      icon: const Icon(Icons.link),\r\n+                                      label: Text('Go to: ${notification['contexturlname']}'),\r\n+                                      onPressed: () {\r\n+                                          // Handle opening the context URL (e.g., in-app webview or external browser)\r\n+                                          developer.log('Open context URL: ${notification['contexturl']}', name: 'NotificationsScreen');\r\n+                                          Navigator.pop(context); // Close bottom sheet first\r\n+                                          // Add url_launcher logic here if needed\r\n+                                      },\r\n+                                  ),\r\n+                           ],\r\n+                       ),\r\n+                  ),\r\n+             ),\r\n+         );\r\n+\r\n+\r\n+        // --- Mark as read ---\r\n+        if (!isRead && notification['id'] != null) {\r\n+          _markAsRead(notification['id'] as int, index);\r\n+        }\r\n+      },\r\n     );\r\n   }\r\n \r\n   @override\r\n   Widget build(BuildContext context) {\r\n     return Scaffold(\r\n-      appBar: AppBar(title: const Text('Notifications')),\r\n-      body: _isLoading\r\n-          ? const Center(child: CircularProgressIndicator())\r\n-          : _notifications.isEmpty\r\n-              ? const Center(child: Text('No notifications found.'))\r\n-              : ListView.builder(\r\n-                  itemCount: _notifications.length,\r\n-                  itemBuilder: (context, index) =>\r\n-                      _buildNotificationItem(_notifications[index]),\r\n-                ),\r\n+      appBar: AppBar(\r\n+         title: Text('Notifications ($_unreadCount unread)'),\r\n+         actions: [\r\n+             // Add a refresh button\r\n+             IconButton(\r\n+                 icon: const Icon(Icons.refresh),\r\n+                 tooltip: 'Refresh Notifications',\r\n+                 onPressed: _isLoading ? null : _fetchNotifications, // Disable while loading\r\n+             ),\r\n+         ],\r\n+      ),\r\n+      body: _buildBody(),\r\n     );\r\n   }\r\n+\r\n+  Widget _buildBody() {\r\n+    if (_isLoading) {\r\n+      return const Center(child: CircularProgressIndicator());\r\n+    }\r\n+\r\n+    if (_error != null) {\r\n+      return Center(\r\n+         child: Padding(\r\n+           padding: const EdgeInsets.all(16.0),\r\n+           child: Column(\r\n+              mainAxisAlignment: MainAxisAlignment.center,\r\n+              children: [\r\n+                 const Icon(Icons.error_outline, color: Colors.red, size: 48),\r\n+                 const SizedBox(height: 16),\r\n+                 Text('Error loading notifications:', textAlign: TextAlign.center, style: Theme.of(context).textTheme.titleMedium),\r\n+                 const SizedBox(height: 8),\r\n+                 Text(_error!, textAlign: TextAlign.center, style: TextStyle(color: Colors.grey[700])),\r\n+                 const SizedBox(height: 20),\r\n+                 ElevatedButton.icon(\r\n+                   icon: const Icon(Icons.refresh),\r\n+                   label: const Text('Retry'),\r\n+                   onPressed: _fetchInitialData, // Retry fetching everything including user ID if needed\r\n+                 )\r\n+              ],\r\n+           ),\r\n+         ),\r\n+      );\r\n+    }\r\n+\r\n+    if (_notifications.isEmpty) {\r\n+      return Center(\r\n+        child: Column(\r\n+          mainAxisAlignment: MainAxisAlignment.center,\r\n+          children: [\r\n+              const Icon(Icons.notifications_off_outlined, size: 60, color: Colors.grey),\r\n+              const SizedBox(height: 16),\r\n+              const Text('No notifications found.'),\r\n+              const SizedBox(height: 20),\r\n+              ElevatedButton.icon(\r\n+                   icon: const Icon(Icons.refresh),\r\n+                   label: const Text('Check Again'),\r\n+                   onPressed: _fetchNotifications,\r\n+              )\r\n+          ],\r\n+        )\r\n+      );\r\n+    }\r\n+\r\n+    // Use RefreshIndicator for pull-to-refresh\r\n+    return RefreshIndicator(\r\n+      onRefresh: _fetchNotifications,\r\n+      child: ListView.separated(\r\n+        itemCount: _notifications.length,\r\n+        separatorBuilder: (context, index) => const Divider(height: 1, indent: 72), // Add separators\r\n+        itemBuilder: (context, index) =>\r\n+            _buildNotificationItem(_notifications[index], index),\r\n+      ),\r\n+    );\r\n+  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744386160110,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,15 @@\n+// lib/features/connection/screens/notifications_screen.dart\r\n import 'package:dio/dio.dart';\r\n import 'package:flutter/material.dart';\r\n import 'package:aybudle/core/services/api_service.dart';\r\n-import 'dart:developer' as developer; // Use aliased developer log\r\n-import 'package:flutter_html/flutter_html.dart'; // Add flutter_html package: flutter pub add flutter_html\r\n+import 'dart:developer' as developer;\r\n+import 'package:flutter_html/flutter_html.dart';\r\n+import 'package:url_launcher/url_launcher.dart'; // Import url_launcher\r\n \r\n+// Enum to represent filter states\r\n+enum NotificationFilter { all, unread, read }\r\n+\r\n class NotificationsScreen extends StatefulWidget {\r\n   final String baseUrl;\r\n   final String token;\r\n \r\n@@ -19,159 +24,166 @@\n }\r\n \r\n class _NotificationsScreenState extends State<NotificationsScreen> {\r\n   bool _isLoading = true;\r\n-  // Store the full response map initially, or just the list if preferred\r\n-  List<Map<String, dynamic>> _notifications = [];\r\n-  int _unreadCount = 0; // Keep track of unread count\r\n-  String? _error; // Store potential error messages\r\n+  List<Map<String, dynamic>> _notifications = []; // Master list from API\r\n+  List<Map<String, dynamic>> _filteredNotifications = []; // List displayed in UI\r\n+  int _unreadCount = 0;\r\n+  String? _error;\r\n   final ApiService _apiService = ApiService();\r\n-  int? _userId; // Store user ID after fetching\r\n+  int? _userId;\r\n+  NotificationFilter _currentFilter = NotificationFilter.all; // Add filter state\r\n \r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n     _fetchInitialData();\r\n   }\r\n \r\n   Future<void> _fetchInitialData() async {\r\n-    // First, get the user ID if not already fetched elsewhere\r\n-    // In a real app, you might get this once after login and store it in a provider/state management solution\r\n     if (_userId == null) {\r\n-       try {\r\n-          developer.log('Fetching user info for notifications...', name: 'NotificationsScreen');\r\n-          final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n-          // Defensive check for userid existence and type\r\n-          if (userInfo.containsKey('userid') && userInfo['userid'] is int) {\r\n-             _userId = userInfo['userid'] as int;\r\n-             developer.log('User ID obtained: $_userId', name: 'NotificationsScreen');\r\n-             await _fetchNotifications(); // Now fetch notifications\r\n-          } else {\r\n-             developer.log('User ID not found or invalid type in user info response: $userInfo', name: 'NotificationsScreen', level: 1000); // Log as error\r\n-             setState(() {\r\n-               _isLoading = false;\r\n-               _error = 'Could not retrieve user information.';\r\n-             });\r\n-          }\r\n-       } catch (e, s) {\r\n-          developer.log('Error fetching user info: $e', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n+      try {\r\n+        developer.log('Fetching user info for notifications...', name: 'NotificationsScreen');\r\n+        final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n+        if (userInfo.containsKey('userid') && userInfo['userid'] is int) {\r\n+          _userId = userInfo['userid'] as int;\r\n+          developer.log('User ID obtained: $_userId', name: 'NotificationsScreen');\r\n+          await _fetchNotificationsUsingCoreMessages(); // Or your preferred fetch function\r\n+        } else {\r\n+          developer.log('User ID not found or invalid type', name: 'NotificationsScreen', level: 1000);\r\n           setState(() {\r\n             _isLoading = false;\r\n-            _error = 'Error getting user info: ${e.toString()}';\r\n+            _error = 'Could not retrieve user information.';\r\n           });\r\n-       }\r\n+        }\r\n+      } catch (e, s) {\r\n+        developer.log('Error fetching user info: $e', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n+        setState(() {\r\n+          _isLoading = false;\r\n+          _error = 'Error getting user info: ${e.toString()}';\r\n+        });\r\n+      }\r\n     } else {\r\n-       await _fetchNotifications(); // User ID already available\r\n+      await _fetchNotificationsUsingCoreMessages(); // Or your preferred fetch function\r\n     }\r\n   }\r\n \r\n+  // Apply the current filter to the master list\r\n+  void _applyFilter() {\r\n+    setState(() { // Update the UI after filtering\r\n+      switch (_currentFilter) {\r\n+        case NotificationFilter.unread:\r\n+          _filteredNotifications = _notifications.where((n) => n['timeread'] == null).toList();\r\n+          break;\r\n+        case NotificationFilter.read:\r\n+          _filteredNotifications = _notifications.where((n) => n['timeread'] != null).toList();\r\n+          break;\r\n+        case NotificationFilter.all:\r\n+        default:\r\n+          _filteredNotifications = List.from(_notifications); // Show all\r\n+          break;\r\n+      }\r\n+    });\r\n+      developer.log('Filter applied: $_currentFilter. Showing ${_filteredNotifications.length} notifications.', name: 'NotificationsScreen');\r\n+  }\r\n \r\n-  Future<void> _fetchNotifications() async {\r\n-    if (_userId == null) {\r\n-       developer.log('Cannot fetch notifications: User ID is null.', name: 'NotificationsScreen', level: 1000);\r\n-       setState(() {\r\n-         _isLoading = false;\r\n-         _error = 'User ID not available.';\r\n-       });\r\n-       return;\r\n-    }\r\n+  Future<void> _fetchNotificationsUsingCoreMessages() async {\r\n+    // ...(existing null check for _userId)...\r\n \r\n     setState(() {\r\n       _isLoading = true;\r\n-      _error = null; // Clear previous errors\r\n+      _error = null;\r\n     });\r\n \r\n     try {\r\n-      developer.log('=== Starting notifications fetch ===', name: 'NotificationsScreen');\r\n-      developer.log('Base URL: ${widget.baseUrl}', name: 'NotificationsScreen');\r\n-      // Avoid logging token in production\r\n-      // developer.log('Token: ${widget.token}', name: 'NotificationsScreen');\r\n-      developer.log('User ID: $_userId', name: 'NotificationsScreen');\r\n+      // ...(existing logging)...\r\n \r\n-      // Get notifications response (expecting a Map)\r\n-      final notificationsResponse = await _apiService.getNotifications(widget.baseUrl, widget.token, _userId!);\r\n-      developer.log('Raw notifications response map:', name: 'NotificationsScreen');\r\n-      developer.log(notificationsResponse.toString(), name: 'NotificationsScreen');\r\n+      final messagesResponse = await _apiService.getCoreMessages(widget.baseUrl, widget.token, _userId!);\r\n+      // ...(existing logging)...\r\n \r\n-      // Extract the list and unread count\r\n-      final List<dynamic> notificationsList = notificationsResponse['notifications'] as List<dynamic>? ?? [];\r\n-      final int unreadCount = notificationsResponse['unreadcount'] as int? ?? 0;\r\n-\r\n-       // Ensure all items in the list are Maps\r\n-      final List<Map<String, dynamic>> typedNotifications = notificationsList\r\n-          .whereType<Map<String, dynamic>>() // Filter out non-map items if any\r\n+      final List<dynamic> messagesList = messagesResponse['messages'] as List<dynamic>? ?? [];\r\n+      final List<Map<String, dynamic>> typedNotifications = messagesList\r\n+          .whereType<Map<String, dynamic>>()\r\n+          .map((msg) {\r\n+              // ...(keep the existing mapping logic)...\r\n+               return {\r\n+                'id': msg['id'] as int? ?? 0,\r\n+                'subject': msg['subject'] as String? ?? msg['fullmessage']?.substring(0, (msg['fullmessage'] as String?)?.length ?? 0 > 30 ? 30 : (msg['fullmessage'] as String?)?.length ?? 0 ) ?? 'No Subject',\r\n+                'smallmessage': msg['smallmessage'] as String? ?? '',\r\n+                'fullmessage': msg['fullmessage'] as String? ?? '',\r\n+                'fullmessageformat': msg['fullmessageformat'] as int? ?? 0,\r\n+                'timecreated': msg['timecreated'] as int? ?? 0,\r\n+                'timeread': msg['timeread'] as int?,\r\n+                'contexturl': msg['contexturl'] as String?,\r\n+                'contexturlname': msg['contexturlname'] as String?,\r\n+                'component': msg['component'] as String?,\r\n+                'eventtype': msg['eventtype'] as String?,\r\n+                'customdata': msg['customdata'] as String?,\r\n+                'iconurl': msg['iconurl'] as String?,\r\n+              };\r\n+           })\r\n           .toList();\r\n \r\n+      final int totalUnreadCount = typedNotifications.where((n) => n['timeread'] == null).length;\r\n+\r\n       setState(() {\r\n-        _notifications = typedNotifications;\r\n-        _unreadCount = unreadCount; // Update unread count\r\n+        _notifications = typedNotifications; // Update master list\r\n+        _unreadCount = totalUnreadCount;   // Update total unread count\r\n         _isLoading = false;\r\n+        _applyFilter(); // Apply the current filter to the new data\r\n       });\r\n \r\n-      developer.log('\\n=== Processed notifications data ===', name: 'NotificationsScreen');\r\n-      developer.log('Number of notifications: ${_notifications.length}', name: 'NotificationsScreen');\r\n-      developer.log('Reported unread count: $_unreadCount', name: 'NotificationsScreen');\r\n-      if (_notifications.isNotEmpty) {\r\n-        developer.log('First notification details:', name: 'NotificationsScreen');\r\n-        developer.log(_notifications.first.toString(), name: 'NotificationsScreen');\r\n-      }\r\n+      // ...(existing logging)...\r\n+\r\n     } catch (e, s) {\r\n-      developer.log('\\n=== Error occurred fetching notifications ===', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n-      if (e is DioException) {\r\n-        developer.log('Dio error details:', name: 'NotificationsScreen', level: 1000);\r\n-        developer.log('Response data: ${e.response?.data}', name: 'NotificationsScreen', level: 1000);\r\n-        developer.log('Status code: ${e.response?.statusCode}', name: 'NotificationsScreen', level: 1000);\r\n-      }\r\n+      developer.log('\\n=== Error occurred fetching core messages ===', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n       setState(() {\r\n-         _isLoading = false;\r\n-         _error = e.toString(); // Display error message\r\n+        _isLoading = false;\r\n+        _error = e.toString();\r\n+        _notifications = []; // Clear lists on error\r\n+        _filteredNotifications = [];\r\n+        _unreadCount = 0;\r\n       });\r\n     }\r\n   }\r\n \r\n-  // Function to mark a notification as read\r\n-  Future<void> _markAsRead(int notificationId, int index) async {\r\n-    // Optimistically update the UI first\r\n+  Future<void> _markAsRead(int notificationId, int indexInFilteredList) async {\r\n+     // Find the corresponding index in the master list\r\n+     final originalIndex = _notifications.indexWhere((n) => n['id'] == _filteredNotifications[indexInFilteredList]['id']);\r\n+     if (originalIndex == -1) {\r\n+         developer.log('Error: Could not find notification in master list to mark as read.', name: 'NotificationsScreen');\r\n+         return;\r\n+     }\r\n+\r\n+    // Optimistically update the UI in both lists\r\n     setState(() {\r\n-      // Find the notification and update its timeread locally\r\n-      // Create a mutable copy if needed\r\n-      // Note: This assumes 'timeread' is the field indicating read status. Adjust if needed.\r\n-       var updatedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n-       if (updatedNotification['timeread'] == null) {\r\n-          updatedNotification['timeread'] = DateTime.now().millisecondsSinceEpoch ~/ 1000;\r\n-          _notifications[index] = updatedNotification;\r\n-          _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length); // Decrement unread count\r\n-       }\r\n+      var updatedNotification = Map<String, dynamic>.from(_notifications[originalIndex]);\r\n+      if (updatedNotification['timeread'] == null) {\r\n+        updatedNotification['timeread'] = DateTime.now().millisecondsSinceEpoch ~/ 1000;\r\n+        _notifications[originalIndex] = updatedNotification; // Update master list\r\n+         _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length);\r\n+        _applyFilter(); // Re-apply filter to update the displayed list\r\n+      }\r\n     });\r\n \r\n-    // Call the API to mark as read\r\n+    // Call the API\r\n     bool success = await _apiService.markNotificationRead(widget.baseUrl, widget.token, notificationId);\r\n \r\n     if (!success) {\r\n-      developer.log('Failed to mark notification $notificationId as read on server.', name: 'NotificationsScreen', level: 900); // Log as warning\r\n-      // Optionally revert the UI change or show a snackbar\r\n-       ScaffoldMessenger.of(context).showSnackBar(\r\n-          const SnackBar(content: Text('Could not mark notification as read on server.')),\r\n-       );\r\n-       // Revert UI change (optional, might cause flicker)\r\n-       /* setState(() {\r\n-          var revertedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n-           if (revertedNotification['timeread'] != null) { // Check if it was actually changed\r\n-              revertedNotification['timeread'] = null;\r\n-              _notifications[index] = revertedNotification;\r\n-              _unreadCount++; // Increment back\r\n-           }\r\n-       }); */\r\n-       // Or just refresh the list entirely to get the true state\r\n-       // await _fetchNotifications();\r\n+      developer.log('Failed to mark notification $notificationId as read on server.', name: 'NotificationsScreen', level: 900);\r\n+      // Optionally revert UI or show snackbar (current implementation keeps optimistic update)\r\n+      ScaffoldMessenger.of(context).showSnackBar(\r\n+         const SnackBar(content: Text('Could not mark notification as read on server.')),\r\n+      );\r\n+      // Consider refreshing from server if strict consistency is needed:\r\n+      // await _fetchNotificationsUsingCoreMessages();\r\n     } else {\r\n        developer.log('Successfully marked notification $notificationId as read on server.', name: 'NotificationsScreen');\r\n-       // UI is already updated, maybe refresh the count from API if needed\r\n     }\r\n   }\r\n \r\n-  // Helper to format the date/time nicely\r\n   String _formatDateTime(int timestamp) {\r\n+    // ...(keep existing implementation)...\r\n     final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);\r\n     final now = DateTime.now();\r\n     final difference = now.difference(dateTime);\r\n \r\n@@ -183,105 +195,153 @@\n       return '${difference.inHours}h ago';\r\n     } else if (difference.inDays < 7) {\r\n       return '${difference.inDays}d ago';\r\n     } else {\r\n-      // Consider using intl package for better date formatting\r\n       return '${dateTime.day}/${dateTime.month}/${dateTime.year}';\r\n     }\r\n   }\r\n \r\n+  // Function to launch URL\r\n+  Future<void> _launchContextUrl(String? urlString, BuildContext sheetContext) async {\r\n+    // Use sheetContext passed from the builder if ScaffoldMessenger might be an issue\r\n+    Navigator.pop(sheetContext); // Close bottom sheet first\r\n+\r\n+    if (urlString == null || urlString.isEmpty) {\r\n+       developer.log('Context URL is null or empty', name: 'NotificationsScreen');\r\n+       ScaffoldMessenger.of(context).showSnackBar(\r\n+         const SnackBar(content: Text('No link available for this notification.')),\r\n+       );\r\n+       return;\r\n+    }\r\n+\r\n+    final Uri? uri = Uri.tryParse(urlString);\r\n+    if (uri != null) {\r\n+      try {\r\n+        developer.log('Attempting to launch URL: $uri', name: 'NotificationsScreen');\r\n+        // Use external application for web links usually\r\n+        if (!await launchUrl(uri, mode: LaunchMode.externalApplication)) {\r\n+          throw Exception('Could not launch $uri');\r\n+        }\r\n+         developer.log('URL Launched successfully', name: 'NotificationsScreen');\r\n+      } catch (e) {\r\n+        developer.log('Could not launch URL: $e', name: 'NotificationsScreen', error: e);\r\n+        // Check if context is still mounted before showing SnackBar\r\n+        if (mounted) {\r\n+             ScaffoldMessenger.of(context).showSnackBar(\r\n+               SnackBar(content: Text('Could not open link: $urlString')),\r\n+             );\r\n+        }\r\n+      }\r\n+    } else {\r\n+      developer.log('Invalid URL format: $urlString', name: 'NotificationsScreen');\r\n+       if (mounted) {\r\n+           ScaffoldMessenger.of(context).showSnackBar(\r\n+             const SnackBar(content: Text('Invalid link format.')),\r\n+           );\r\n+       }\r\n+    }\r\n+  }\r\n+\r\n+\r\n   Widget _buildNotificationItem(Map<String, dynamic> notification, int index) {\r\n+    // ...(keep existing implementation, including iconUrl handling if you added it)...\r\n     final bool isRead = notification['timeread'] != null;\r\n     final int timeCreated = notification['timecreated'] as int? ?? 0;\r\n     final String subject = notification['subject'] as String? ?? 'No Subject';\r\n-    final String smallMessage = notification['smallmessage'] as String? ?? ''; // Usually plain text\r\n-    // final String fullMessage = notification['fullmessage'] as String? ?? ''; // Often HTML\r\n-    // final int fullMessageFormat = notification['fullmessageformat'] as int? ?? 0; // 1=HTML, 0=Markdown, 2=Plain, 4=Legacy Moodle Auto\r\n+    final String smallMessage = notification['smallmessage'] as String? ?? '';\r\n+    final String? iconUrl = notification['iconurl'] as String?;\r\n \r\n     return ListTile(\r\n-      // Leading icon changes based on read status\r\n-      leading: Icon(\r\n-        isRead ? Icons.notifications_none : Icons.notifications_active,\r\n-        color: isRead ? Colors.grey : Theme.of(context).colorScheme.primary,\r\n-      ),\r\n-      // Title is bolder if unread\r\n-      title: Text(\r\n+      leading: iconUrl != null && iconUrl.isNotEmpty // Ensure iconUrl is not empty\r\n+          ? CircleAvatar(\r\n+              backgroundImage: NetworkImage(iconUrl),\r\n+              backgroundColor: Colors.transparent,\r\n+              onBackgroundImageError: (exception, stackTrace) { // Handle image load error\r\n+                 developer.log('Failed to load icon: $iconUrl', name:'NotificationsScreen', error: exception);\r\n+                 // Optionally show a placeholder or fallback icon here\r\n+              },\r\n+              radius: 20, // Adjust size as needed\r\n+              // Optional: add unread indicator overlay if needed\r\n+            )\r\n+          : Icon( // Fallback icon\r\n+              isRead ? Icons.notifications_none_outlined : Icons.notifications_active,\r\n+              color: isRead ? Colors.grey : Theme.of(context).colorScheme.primary,\r\n+            ),\r\n+       title: Text(\r\n         subject,\r\n         style: TextStyle(\r\n           fontWeight: isRead ? FontWeight.normal : FontWeight.bold,\r\n         ),\r\n+        maxLines: 1,\r\n+        overflow: TextOverflow.ellipsis,\r\n       ),\r\n-      // Use small message as subtitle\r\n       subtitle: Text(\r\n           smallMessage,\r\n           maxLines: 2,\r\n           overflow: TextOverflow.ellipsis,\r\n       ),\r\n-      // Show relative time\r\n-      trailing: timeCreated > 0\r\n+       trailing: timeCreated > 0\r\n           ? Text(\r\n                _formatDateTime(timeCreated),\r\n                style: TextStyle(fontSize: 12, color: Colors.grey[600]),\r\n             )\r\n           : null,\r\n-      isThreeLine: smallMessage.isNotEmpty, // Allow more space if subtitle exists\r\n+      isThreeLine: smallMessage.isNotEmpty,\r\n       onTap: () {\r\n         developer.log('Tapped notification ID: ${notification['id']}', name: 'NotificationsScreen');\r\n \r\n-        // --- Show details in a dialog/bottom sheet ---\r\n-         showModalBottomSheet(\r\n-             context: context,\r\n-             isScrollControlled: true, // Allow full height\r\n-             builder: (context) => DraggableScrollableSheet(\r\n-                  initialChildSize: 0.6, // Start at 60% height\r\n-                  minChildSize: 0.3,\r\n-                  maxChildSize: 0.9, // Allow almost full height\r\n-                  expand: false,\r\n-                  builder: (_, scrollController) => Container(\r\n-                       padding: const EdgeInsets.all(16.0),\r\n-                       child: ListView( // Use ListView for scrolling long content\r\n-                           controller: scrollController,\r\n-                           children: [\r\n-                               Text(\r\n-                                   subject,\r\n-                                   style: Theme.of(context).textTheme.headlineSmall?.copyWith(\r\n-                                        fontWeight: isRead ? FontWeight.normal : FontWeight.bold,\r\n-                                   )\r\n-                               ),\r\n-                               const SizedBox(height: 8),\r\n-                               if (timeCreated > 0)\r\n-                                  Text(\r\n-                                      'Received: ${_formatDateTime(timeCreated)}',\r\n-                                      style: TextStyle(fontSize: 12, color: Colors.grey[700]),\r\n-                                  ),\r\n-                               const Divider(height: 24),\r\n-                               // Render HTML content safely\r\n-                               if (notification['fullmessage'] != null)\r\n-                                  Html(data: notification['fullmessage'] as String)\r\n-                               else\r\n-                                  Text(smallMessage), // Fallback to small message\r\n-                               const SizedBox(height: 20),\r\n-                               // Optionally add context link button\r\n-                               if (notification['contexturl'] != null && notification['contexturlname'] != null)\r\n-                                  ElevatedButton.icon(\r\n-                                      icon: const Icon(Icons.link),\r\n-                                      label: Text('Go to: ${notification['contexturlname']}'),\r\n-                                      onPressed: () {\r\n-                                          // Handle opening the context URL (e.g., in-app webview or external browser)\r\n-                                          developer.log('Open context URL: ${notification['contexturl']}', name: 'NotificationsScreen');\r\n-                                          Navigator.pop(context); // Close bottom sheet first\r\n-                                          // Add url_launcher logic here if needed\r\n-                                      },\r\n-                                  ),\r\n-                           ],\r\n-                       ),\r\n+        showModalBottomSheet(\r\n+          context: context,\r\n+          isScrollControlled: true,\r\n+          builder: (sheetContext) => DraggableScrollableSheet( // Pass sheetContext\r\n+            initialChildSize: 0.6,\r\n+            minChildSize: 0.3,\r\n+            maxChildSize: 0.9,\r\n+            expand: false,\r\n+            builder: (_, scrollController) => Container(\r\n+              padding: const EdgeInsets.all(16.0),\r\n+              child: ListView(\r\n+                controller: scrollController,\r\n+                children: [\r\n+                  Text(\r\n+                      subject,\r\n+                      style: Theme.of(context).textTheme.headlineSmall?.copyWith(\r\n+                           fontWeight: isRead ? FontWeight.normal : FontWeight.bold,\r\n+                      )\r\n                   ),\r\n-             ),\r\n-         );\r\n+                  const SizedBox(height: 8),\r\n+                  if (timeCreated > 0)\r\n+                    Text(\r\n+                        'Received: ${_formatDateTime(timeCreated)}',\r\n+                        style: TextStyle(fontSize: 12, color: Colors.grey[700]),\r\n+                    ),\r\n+                  const Divider(height: 24),\r\n+                  if (notification['fullmessage'] != null && (notification['fullmessage'] as String).isNotEmpty)\r\n+                    Html(data: notification['fullmessage'] as String)\r\n+                  else\r\n+                    Text(smallMessage.isNotEmpty ? smallMessage : '(No details available)'), // Fallback\r\n+                  const SizedBox(height: 20),\r\n+                  // Context link button\r\n+                  if (notification['contexturl'] != null &&\r\n+                      (notification['contexturl'] as String).isNotEmpty &&\r\n+                      notification['contexturlname'] != null &&\r\n+                      (notification['contexturlname'] as String).isNotEmpty)\r\n+                    ElevatedButton.icon(\r\n+                      icon: const Icon(Icons.link),\r\n+                      label: Text('Go to: ${notification['contexturlname']}'),\r\n+                      onPressed: () {\r\n+                         // Use the new launch function\r\n+                         _launchContextUrl(notification['contexturl'] as String?, sheetContext);\r\n+                      },\r\n+                    ),\r\n+                ],\r\n+              ),\r\n+            ),\r\n+          ),\r\n+        );\r\n \r\n-\r\n-        // --- Mark as read ---\r\n-        if (!isRead && notification['id'] != null) {\r\n+        // Mark as read (pass the index from the *filtered* list)\r\n+        if (!isRead && notification['id'] != null && notification['id'] != 0) {\r\n           _markAsRead(notification['id'] as int, index);\r\n         }\r\n       },\r\n     );\r\n@@ -290,17 +350,45 @@\n   @override\r\n   Widget build(BuildContext context) {\r\n     return Scaffold(\r\n       appBar: AppBar(\r\n-         title: Text('Notifications ($_unreadCount unread)'),\r\n-         actions: [\r\n-             // Add a refresh button\r\n-             IconButton(\r\n-                 icon: const Icon(Icons.refresh),\r\n-                 tooltip: 'Refresh Notifications',\r\n-                 onPressed: _isLoading ? null : _fetchNotifications, // Disable while loading\r\n-             ),\r\n-         ],\r\n+        // Show total unread count, not filtered count\r\n+        title: Text('Notifications ($_unreadCount unread)'),\r\n+        actions: [\r\n+          // Refresh Button\r\n+          IconButton(\r\n+            icon: const Icon(Icons.refresh),\r\n+            tooltip: 'Refresh Notifications',\r\n+            onPressed: _isLoading ? null : _fetchNotificationsUsingCoreMessages, // Or your preferred function\r\n+          ),\r\n+          // Filter Button\r\n+          PopupMenuButton<NotificationFilter>(\r\n+            tooltip: 'Filter Notifications',\r\n+            icon: const Icon(Icons.filter_list),\r\n+            onSelected: (NotificationFilter result) {\r\n+               if (_currentFilter != result) { // Only apply if filter changed\r\n+                   setState(() {\r\n+                      _currentFilter = result;\r\n+                   });\r\n+                   _applyFilter(); // Apply the new filter\r\n+               }\r\n+            },\r\n+            itemBuilder: (BuildContext context) => <PopupMenuEntry<NotificationFilter>>[\r\n+              const PopupMenuItem<NotificationFilter>(\r\n+                value: NotificationFilter.all,\r\n+                child: Text('Show All'),\r\n+              ),\r\n+              const PopupMenuItem<NotificationFilter>(\r\n+                value: NotificationFilter.unread,\r\n+                child: Text('Show Unread'),\r\n+              ),\r\n+              const PopupMenuItem<NotificationFilter>(\r\n+                value: NotificationFilter.read,\r\n+                child: Text('Show Read'),\r\n+              ),\r\n+            ],\r\n+          ),\r\n+        ],\r\n       ),\r\n       body: _buildBody(),\r\n     );\r\n   }\r\n@@ -310,9 +398,10 @@\n       return const Center(child: CircularProgressIndicator());\r\n     }\r\n \r\n     if (_error != null) {\r\n-      return Center(\r\n+      // ...(keep existing error display)...\r\n+        return Center(\r\n          child: Padding(\r\n            padding: const EdgeInsets.all(16.0),\r\n            child: Column(\r\n               mainAxisAlignment: MainAxisAlignment.center,\r\n@@ -325,43 +414,59 @@\n                  const SizedBox(height: 20),\r\n                  ElevatedButton.icon(\r\n                    icon: const Icon(Icons.refresh),\r\n                    label: const Text('Retry'),\r\n-                   onPressed: _fetchInitialData, // Retry fetching everything including user ID if needed\r\n+                   onPressed: _fetchNotificationsUsingCoreMessages, // Or your preferred function\r\n                  )\r\n               ],\r\n            ),\r\n          ),\r\n       );\r\n     }\r\n \r\n+    // Handle case where master list is empty vs filtered list is empty\r\n     if (_notifications.isEmpty) {\r\n       return Center(\r\n         child: Column(\r\n           mainAxisAlignment: MainAxisAlignment.center,\r\n           children: [\r\n-              const Icon(Icons.notifications_off_outlined, size: 60, color: Colors.grey),\r\n-              const SizedBox(height: 16),\r\n-              const Text('No notifications found.'),\r\n-              const SizedBox(height: 20),\r\n-              ElevatedButton.icon(\r\n-                   icon: const Icon(Icons.refresh),\r\n-                   label: const Text('Check Again'),\r\n-                   onPressed: _fetchNotifications,\r\n-              )\r\n+            const Icon(Icons.notifications_off_outlined, size: 60, color: Colors.grey),\r\n+            const SizedBox(height: 16),\r\n+            const Text('No notifications found.'),\r\n+            const SizedBox(height: 20),\r\n+            ElevatedButton.icon(\r\n+              icon: const Icon(Icons.refresh),\r\n+              label: const Text('Check Again'),\r\n+              onPressed: _fetchNotificationsUsingCoreMessages, // Or your preferred function\r\n+            )\r\n           ],\r\n         )\r\n       );\r\n     }\r\n \r\n-    // Use RefreshIndicator for pull-to-refresh\r\n+    // If master list is not empty, but filtered list is\r\n+    if (_filteredNotifications.isEmpty) {\r\n+        return Center(\r\n+          child: Column(\r\n+            mainAxisAlignment: MainAxisAlignment.center,\r\n+            children: [\r\n+              Icon(Icons.filter_alt_off_outlined, size: 60, color: Colors.grey),\r\n+              const SizedBox(height: 16),\r\n+              Text('No notifications match the \"${_currentFilter.name}\" filter.'), // Show current filter\r\n+            ],\r\n+          )\r\n+        );\r\n+    }\r\n+\r\n+\r\n+    // Use the filtered list here\r\n     return RefreshIndicator(\r\n-      onRefresh: _fetchNotifications,\r\n+      onRefresh: _fetchNotificationsUsingCoreMessages, // Or your preferred function\r\n       child: ListView.separated(\r\n-        itemCount: _notifications.length,\r\n-        separatorBuilder: (context, index) => const Divider(height: 1, indent: 72), // Add separators\r\n+        itemCount: _filteredNotifications.length, // Use filtered list length\r\n+        separatorBuilder: (context, index) => const Divider(height: 1, indent: 72),\r\n         itemBuilder: (context, index) =>\r\n-            _buildNotificationItem(_notifications[index], index),\r\n+            _buildNotificationItem(_filteredNotifications[index], index), // Use filtered list item\r\n       ),\r\n     );\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744386256006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,11 @@\n-// lib/features/connection/screens/notifications_screen.dart\r\n import 'package:dio/dio.dart';\r\n import 'package:flutter/material.dart';\r\n import 'package:aybudle/core/services/api_service.dart';\r\n import 'dart:developer' as developer;\r\n import 'package:flutter_html/flutter_html.dart';\r\n-import 'package:url_launcher/url_launcher.dart'; // Import url_launcher\r\n+import 'package:url_launcher/url_launcher.dart';\r\n \r\n-// Enum to represent filter states\r\n-enum NotificationFilter { all, unread, read }\r\n-\r\n class NotificationsScreen extends StatefulWidget {\r\n   final String baseUrl;\r\n   final String token;\r\n \r\n@@ -24,166 +20,159 @@\n }\r\n \r\n class _NotificationsScreenState extends State<NotificationsScreen> {\r\n   bool _isLoading = true;\r\n-  List<Map<String, dynamic>> _notifications = []; // Master list from API\r\n-  List<Map<String, dynamic>> _filteredNotifications = []; // List displayed in UI\r\n-  int _unreadCount = 0;\r\n-  String? _error;\r\n+  // Store the full response map initially, or just the list if preferred\r\n+  List<Map<String, dynamic>> _notifications = [];\r\n+  int _unreadCount = 0; // Keep track of unread count\r\n+  String? _error; // Store potential error messages\r\n   final ApiService _apiService = ApiService();\r\n-  int? _userId;\r\n-  NotificationFilter _currentFilter = NotificationFilter.all; // Add filter state\r\n+  int? _userId; // Store user ID after fetching\r\n \r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n     _fetchInitialData();\r\n   }\r\n \r\n   Future<void> _fetchInitialData() async {\r\n+    // First, get the user ID if not already fetched elsewhere\r\n+    // In a real app, you might get this once after login and store it in a provider/state management solution\r\n     if (_userId == null) {\r\n-      try {\r\n-        developer.log('Fetching user info for notifications...', name: 'NotificationsScreen');\r\n-        final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n-        if (userInfo.containsKey('userid') && userInfo['userid'] is int) {\r\n-          _userId = userInfo['userid'] as int;\r\n-          developer.log('User ID obtained: $_userId', name: 'NotificationsScreen');\r\n-          await _fetchNotificationsUsingCoreMessages(); // Or your preferred fetch function\r\n-        } else {\r\n-          developer.log('User ID not found or invalid type', name: 'NotificationsScreen', level: 1000);\r\n+       try {\r\n+          developer.log('Fetching user info for notifications...', name: 'NotificationsScreen');\r\n+          final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n+          // Defensive check for userid existence and type\r\n+          if (userInfo.containsKey('userid') && userInfo['userid'] is int) {\r\n+             _userId = userInfo['userid'] as int;\r\n+             developer.log('User ID obtained: $_userId', name: 'NotificationsScreen');\r\n+             await _fetchNotifications(); // Now fetch notifications\r\n+          } else {\r\n+             developer.log('User ID not found or invalid type in user info response: $userInfo', name: 'NotificationsScreen', level: 1000); // Log as error\r\n+             setState(() {\r\n+               _isLoading = false;\r\n+               _error = 'Could not retrieve user information.';\r\n+             });\r\n+          }\r\n+       } catch (e, s) {\r\n+          developer.log('Error fetching user info: $e', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n           setState(() {\r\n             _isLoading = false;\r\n-            _error = 'Could not retrieve user information.';\r\n+            _error = 'Error getting user info: ${e.toString()}';\r\n           });\r\n-        }\r\n-      } catch (e, s) {\r\n-        developer.log('Error fetching user info: $e', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n-        setState(() {\r\n-          _isLoading = false;\r\n-          _error = 'Error getting user info: ${e.toString()}';\r\n-        });\r\n-      }\r\n+       }\r\n     } else {\r\n-      await _fetchNotificationsUsingCoreMessages(); // Or your preferred fetch function\r\n+       await _fetchNotifications(); // User ID already available\r\n     }\r\n   }\r\n \r\n-  // Apply the current filter to the master list\r\n-  void _applyFilter() {\r\n-    setState(() { // Update the UI after filtering\r\n-      switch (_currentFilter) {\r\n-        case NotificationFilter.unread:\r\n-          _filteredNotifications = _notifications.where((n) => n['timeread'] == null).toList();\r\n-          break;\r\n-        case NotificationFilter.read:\r\n-          _filteredNotifications = _notifications.where((n) => n['timeread'] != null).toList();\r\n-          break;\r\n-        case NotificationFilter.all:\r\n-        default:\r\n-          _filteredNotifications = List.from(_notifications); // Show all\r\n-          break;\r\n-      }\r\n-    });\r\n-      developer.log('Filter applied: $_currentFilter. Showing ${_filteredNotifications.length} notifications.', name: 'NotificationsScreen');\r\n-  }\r\n \r\n-  Future<void> _fetchNotificationsUsingCoreMessages() async {\r\n-    // ...(existing null check for _userId)...\r\n+  Future<void> _fetchNotifications() async {\r\n+    if (_userId == null) {\r\n+       developer.log('Cannot fetch notifications: User ID is null.', name: 'NotificationsScreen', level: 1000);\r\n+       setState(() {\r\n+         _isLoading = false;\r\n+         _error = 'User ID not available.';\r\n+       });\r\n+       return;\r\n+    }\r\n \r\n     setState(() {\r\n       _isLoading = true;\r\n-      _error = null;\r\n+      _error = null; // Clear previous errors\r\n     });\r\n \r\n     try {\r\n-      // ...(existing logging)...\r\n+      developer.log('=== Starting notifications fetch ===', name: 'NotificationsScreen');\r\n+      developer.log('Base URL: ${widget.baseUrl}', name: 'NotificationsScreen');\r\n+      // Avoid logging token in production\r\n+      // developer.log('Token: ${widget.token}', name: 'NotificationsScreen');\r\n+      developer.log('User ID: $_userId', name: 'NotificationsScreen');\r\n \r\n-      final messagesResponse = await _apiService.getCoreMessages(widget.baseUrl, widget.token, _userId!);\r\n-      // ...(existing logging)...\r\n+      // Get notifications response (expecting a Map)\r\n+      final notificationsResponse = await _apiService.getNotifications(widget.baseUrl, widget.token, _userId!);\r\n+      developer.log('Raw notifications response map:', name: 'NotificationsScreen');\r\n+      developer.log(notificationsResponse.toString(), name: 'NotificationsScreen');\r\n \r\n-      final List<dynamic> messagesList = messagesResponse['messages'] as List<dynamic>? ?? [];\r\n-      final List<Map<String, dynamic>> typedNotifications = messagesList\r\n-          .whereType<Map<String, dynamic>>()\r\n-          .map((msg) {\r\n-              // ...(keep the existing mapping logic)...\r\n-               return {\r\n-                'id': msg['id'] as int? ?? 0,\r\n-                'subject': msg['subject'] as String? ?? msg['fullmessage']?.substring(0, (msg['fullmessage'] as String?)?.length ?? 0 > 30 ? 30 : (msg['fullmessage'] as String?)?.length ?? 0 ) ?? 'No Subject',\r\n-                'smallmessage': msg['smallmessage'] as String? ?? '',\r\n-                'fullmessage': msg['fullmessage'] as String? ?? '',\r\n-                'fullmessageformat': msg['fullmessageformat'] as int? ?? 0,\r\n-                'timecreated': msg['timecreated'] as int? ?? 0,\r\n-                'timeread': msg['timeread'] as int?,\r\n-                'contexturl': msg['contexturl'] as String?,\r\n-                'contexturlname': msg['contexturlname'] as String?,\r\n-                'component': msg['component'] as String?,\r\n-                'eventtype': msg['eventtype'] as String?,\r\n-                'customdata': msg['customdata'] as String?,\r\n-                'iconurl': msg['iconurl'] as String?,\r\n-              };\r\n-           })\r\n+      // Extract the list and unread count\r\n+      final List<dynamic> notificationsList = notificationsResponse['notifications'] as List<dynamic>? ?? [];\r\n+      final int unreadCount = notificationsResponse['unreadcount'] as int? ?? 0;\r\n+\r\n+       // Ensure all items in the list are Maps\r\n+      final List<Map<String, dynamic>> typedNotifications = notificationsList\r\n+          .whereType<Map<String, dynamic>>() // Filter out non-map items if any\r\n           .toList();\r\n \r\n-      final int totalUnreadCount = typedNotifications.where((n) => n['timeread'] == null).length;\r\n-\r\n       setState(() {\r\n-        _notifications = typedNotifications; // Update master list\r\n-        _unreadCount = totalUnreadCount;   // Update total unread count\r\n+        _notifications = typedNotifications;\r\n+        _unreadCount = unreadCount; // Update unread count\r\n         _isLoading = false;\r\n-        _applyFilter(); // Apply the current filter to the new data\r\n       });\r\n \r\n-      // ...(existing logging)...\r\n-\r\n+      developer.log('\\n=== Processed notifications data ===', name: 'NotificationsScreen');\r\n+      developer.log('Number of notifications: ${_notifications.length}', name: 'NotificationsScreen');\r\n+      developer.log('Reported unread count: $_unreadCount', name: 'NotificationsScreen');\r\n+      if (_notifications.isNotEmpty) {\r\n+        developer.log('First notification details:', name: 'NotificationsScreen');\r\n+        developer.log(_notifications.first.toString(), name: 'NotificationsScreen');\r\n+      }\r\n     } catch (e, s) {\r\n-      developer.log('\\n=== Error occurred fetching core messages ===', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n+      developer.log('\\n=== Error occurred fetching notifications ===', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n+      if (e is DioException) {\r\n+        developer.log('Dio error details:', name: 'NotificationsScreen', level: 1000);\r\n+        developer.log('Response data: ${e.response?.data}', name: 'NotificationsScreen', level: 1000);\r\n+        developer.log('Status code: ${e.response?.statusCode}', name: 'NotificationsScreen', level: 1000);\r\n+      }\r\n       setState(() {\r\n-        _isLoading = false;\r\n-        _error = e.toString();\r\n-        _notifications = []; // Clear lists on error\r\n-        _filteredNotifications = [];\r\n-        _unreadCount = 0;\r\n+         _isLoading = false;\r\n+         _error = e.toString(); // Display error message\r\n       });\r\n     }\r\n   }\r\n \r\n-  Future<void> _markAsRead(int notificationId, int indexInFilteredList) async {\r\n-     // Find the corresponding index in the master list\r\n-     final originalIndex = _notifications.indexWhere((n) => n['id'] == _filteredNotifications[indexInFilteredList]['id']);\r\n-     if (originalIndex == -1) {\r\n-         developer.log('Error: Could not find notification in master list to mark as read.', name: 'NotificationsScreen');\r\n-         return;\r\n-     }\r\n-\r\n-    // Optimistically update the UI in both lists\r\n+  // Function to mark a notification as read\r\n+  Future<void> _markAsRead(int notificationId, int index) async {\r\n+    // Optimistically update the UI first\r\n     setState(() {\r\n-      var updatedNotification = Map<String, dynamic>.from(_notifications[originalIndex]);\r\n-      if (updatedNotification['timeread'] == null) {\r\n-        updatedNotification['timeread'] = DateTime.now().millisecondsSinceEpoch ~/ 1000;\r\n-        _notifications[originalIndex] = updatedNotification; // Update master list\r\n-         _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length);\r\n-        _applyFilter(); // Re-apply filter to update the displayed list\r\n-      }\r\n+      // Find the notification and update its timeread locally\r\n+      // Create a mutable copy if needed\r\n+      // Note: This assumes 'timeread' is the field indicating read status. Adjust if needed.\r\n+       var updatedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n+       if (updatedNotification['timeread'] == null) {\r\n+          updatedNotification['timeread'] = DateTime.now().millisecondsSinceEpoch ~/ 1000;\r\n+          _notifications[index] = updatedNotification;\r\n+          _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length); // Decrement unread count\r\n+       }\r\n     });\r\n \r\n-    // Call the API\r\n+    // Call the API to mark as read\r\n     bool success = await _apiService.markNotificationRead(widget.baseUrl, widget.token, notificationId);\r\n \r\n     if (!success) {\r\n-      developer.log('Failed to mark notification $notificationId as read on server.', name: 'NotificationsScreen', level: 900);\r\n-      // Optionally revert UI or show snackbar (current implementation keeps optimistic update)\r\n-      ScaffoldMessenger.of(context).showSnackBar(\r\n-         const SnackBar(content: Text('Could not mark notification as read on server.')),\r\n-      );\r\n-      // Consider refreshing from server if strict consistency is needed:\r\n-      // await _fetchNotificationsUsingCoreMessages();\r\n+      developer.log('Failed to mark notification $notificationId as read on server.', name: 'NotificationsScreen', level: 900); // Log as warning\r\n+      // Optionally revert the UI change or show a snackbar\r\n+       ScaffoldMessenger.of(context).showSnackBar(\r\n+          const SnackBar(content: Text('Could not mark notification as read on server.')),\r\n+       );\r\n+       // Revert UI change (optional, might cause flicker)\r\n+       /* setState(() {\r\n+          var revertedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n+           if (revertedNotification['timeread'] != null) { // Check if it was actually changed\r\n+              revertedNotification['timeread'] = null;\r\n+              _notifications[index] = revertedNotification;\r\n+              _unreadCount++; // Increment back\r\n+           }\r\n+       }); */\r\n+       // Or just refresh the list entirely to get the true state\r\n+       // await _fetchNotifications();\r\n     } else {\r\n        developer.log('Successfully marked notification $notificationId as read on server.', name: 'NotificationsScreen');\r\n+       // UI is already updated, maybe refresh the count from API if needed\r\n     }\r\n   }\r\n \r\n+  // Helper to format the date/time nicely\r\n   String _formatDateTime(int timestamp) {\r\n-    // ...(keep existing implementation)...\r\n     final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);\r\n     final now = DateTime.now();\r\n     final difference = now.difference(dateTime);\r\n \r\n@@ -195,153 +184,105 @@\n       return '${difference.inHours}h ago';\r\n     } else if (difference.inDays < 7) {\r\n       return '${difference.inDays}d ago';\r\n     } else {\r\n+      // Consider using intl package for better date formatting\r\n       return '${dateTime.day}/${dateTime.month}/${dateTime.year}';\r\n     }\r\n   }\r\n \r\n-  // Function to launch URL\r\n-  Future<void> _launchContextUrl(String? urlString, BuildContext sheetContext) async {\r\n-    // Use sheetContext passed from the builder if ScaffoldMessenger might be an issue\r\n-    Navigator.pop(sheetContext); // Close bottom sheet first\r\n-\r\n-    if (urlString == null || urlString.isEmpty) {\r\n-       developer.log('Context URL is null or empty', name: 'NotificationsScreen');\r\n-       ScaffoldMessenger.of(context).showSnackBar(\r\n-         const SnackBar(content: Text('No link available for this notification.')),\r\n-       );\r\n-       return;\r\n-    }\r\n-\r\n-    final Uri? uri = Uri.tryParse(urlString);\r\n-    if (uri != null) {\r\n-      try {\r\n-        developer.log('Attempting to launch URL: $uri', name: 'NotificationsScreen');\r\n-        // Use external application for web links usually\r\n-        if (!await launchUrl(uri, mode: LaunchMode.externalApplication)) {\r\n-          throw Exception('Could not launch $uri');\r\n-        }\r\n-         developer.log('URL Launched successfully', name: 'NotificationsScreen');\r\n-      } catch (e) {\r\n-        developer.log('Could not launch URL: $e', name: 'NotificationsScreen', error: e);\r\n-        // Check if context is still mounted before showing SnackBar\r\n-        if (mounted) {\r\n-             ScaffoldMessenger.of(context).showSnackBar(\r\n-               SnackBar(content: Text('Could not open link: $urlString')),\r\n-             );\r\n-        }\r\n-      }\r\n-    } else {\r\n-      developer.log('Invalid URL format: $urlString', name: 'NotificationsScreen');\r\n-       if (mounted) {\r\n-           ScaffoldMessenger.of(context).showSnackBar(\r\n-             const SnackBar(content: Text('Invalid link format.')),\r\n-           );\r\n-       }\r\n-    }\r\n-  }\r\n-\r\n-\r\n   Widget _buildNotificationItem(Map<String, dynamic> notification, int index) {\r\n-    // ...(keep existing implementation, including iconUrl handling if you added it)...\r\n     final bool isRead = notification['timeread'] != null;\r\n     final int timeCreated = notification['timecreated'] as int? ?? 0;\r\n     final String subject = notification['subject'] as String? ?? 'No Subject';\r\n-    final String smallMessage = notification['smallmessage'] as String? ?? '';\r\n-    final String? iconUrl = notification['iconurl'] as String?;\r\n+    final String smallMessage = notification['smallmessage'] as String? ?? ''; // Usually plain text\r\n+    // final String fullMessage = notification['fullmessage'] as String? ?? ''; // Often HTML\r\n+    // final int fullMessageFormat = notification['fullmessageformat'] as int? ?? 0; // 1=HTML, 0=Markdown, 2=Plain, 4=Legacy Moodle Auto\r\n \r\n     return ListTile(\r\n-      leading: iconUrl != null && iconUrl.isNotEmpty // Ensure iconUrl is not empty\r\n-          ? CircleAvatar(\r\n-              backgroundImage: NetworkImage(iconUrl),\r\n-              backgroundColor: Colors.transparent,\r\n-              onBackgroundImageError: (exception, stackTrace) { // Handle image load error\r\n-                 developer.log('Failed to load icon: $iconUrl', name:'NotificationsScreen', error: exception);\r\n-                 // Optionally show a placeholder or fallback icon here\r\n-              },\r\n-              radius: 20, // Adjust size as needed\r\n-              // Optional: add unread indicator overlay if needed\r\n-            )\r\n-          : Icon( // Fallback icon\r\n-              isRead ? Icons.notifications_none_outlined : Icons.notifications_active,\r\n-              color: isRead ? Colors.grey : Theme.of(context).colorScheme.primary,\r\n-            ),\r\n-       title: Text(\r\n+      // Leading icon changes based on read status\r\n+      leading: Icon(\r\n+        isRead ? Icons.notifications_none : Icons.notifications_active,\r\n+        color: isRead ? Colors.grey : Theme.of(context).colorScheme.primary,\r\n+      ),\r\n+      // Title is bolder if unread\r\n+      title: Text(\r\n         subject,\r\n         style: TextStyle(\r\n           fontWeight: isRead ? FontWeight.normal : FontWeight.bold,\r\n         ),\r\n-        maxLines: 1,\r\n-        overflow: TextOverflow.ellipsis,\r\n       ),\r\n+      // Use small message as subtitle\r\n       subtitle: Text(\r\n           smallMessage,\r\n           maxLines: 2,\r\n           overflow: TextOverflow.ellipsis,\r\n       ),\r\n-       trailing: timeCreated > 0\r\n+      // Show relative time\r\n+      trailing: timeCreated > 0\r\n           ? Text(\r\n                _formatDateTime(timeCreated),\r\n                style: TextStyle(fontSize: 12, color: Colors.grey[600]),\r\n             )\r\n           : null,\r\n-      isThreeLine: smallMessage.isNotEmpty,\r\n+      isThreeLine: smallMessage.isNotEmpty, // Allow more space if subtitle exists\r\n       onTap: () {\r\n         developer.log('Tapped notification ID: ${notification['id']}', name: 'NotificationsScreen');\r\n \r\n-        showModalBottomSheet(\r\n-          context: context,\r\n-          isScrollControlled: true,\r\n-          builder: (sheetContext) => DraggableScrollableSheet( // Pass sheetContext\r\n-            initialChildSize: 0.6,\r\n-            minChildSize: 0.3,\r\n-            maxChildSize: 0.9,\r\n-            expand: false,\r\n-            builder: (_, scrollController) => Container(\r\n-              padding: const EdgeInsets.all(16.0),\r\n-              child: ListView(\r\n-                controller: scrollController,\r\n-                children: [\r\n-                  Text(\r\n-                      subject,\r\n-                      style: Theme.of(context).textTheme.headlineSmall?.copyWith(\r\n-                           fontWeight: isRead ? FontWeight.normal : FontWeight.bold,\r\n-                      )\r\n+        // --- Show details in a dialog/bottom sheet ---\r\n+         showModalBottomSheet(\r\n+             context: context,\r\n+             isScrollControlled: true, // Allow full height\r\n+             builder: (context) => DraggableScrollableSheet(\r\n+                  initialChildSize: 0.6, // Start at 60% height\r\n+                  minChildSize: 0.3,\r\n+                  maxChildSize: 0.9, // Allow almost full height\r\n+                  expand: false,\r\n+                  builder: (_, scrollController) => Container(\r\n+                       padding: const EdgeInsets.all(16.0),\r\n+                       child: ListView( // Use ListView for scrolling long content\r\n+                           controller: scrollController,\r\n+                           children: [\r\n+                               Text(\r\n+                                   subject,\r\n+                                   style: Theme.of(context).textTheme.headlineSmall?.copyWith(\r\n+                                        fontWeight: isRead ? FontWeight.normal : FontWeight.bold,\r\n+                                   )\r\n+                               ),\r\n+                               const SizedBox(height: 8),\r\n+                               if (timeCreated > 0)\r\n+                                  Text(\r\n+                                      'Received: ${_formatDateTime(timeCreated)}',\r\n+                                      style: TextStyle(fontSize: 12, color: Colors.grey[700]),\r\n+                                  ),\r\n+                               const Divider(height: 24),\r\n+                               // Render HTML content safely\r\n+                               if (notification['fullmessage'] != null)\r\n+                                  Html(data: notification['fullmessage'] as String)\r\n+                               else\r\n+                                  Text(smallMessage), // Fallback to small message\r\n+                               const SizedBox(height: 20),\r\n+                               // Optionally add context link button\r\n+                               if (notification['contexturl'] != null && notification['contexturlname'] != null)\r\n+                                  ElevatedButton.icon(\r\n+                                      icon: const Icon(Icons.link),\r\n+                                      label: Text('Go to: ${notification['contexturlname']}'),\r\n+                                      onPressed: () {\r\n+                                          // Handle opening the context URL (e.g., in-app webview or external browser)\r\n+                                          developer.log('Open context URL: ${notification['contexturl']}', name: 'NotificationsScreen');\r\n+                                          Navigator.pop(context); // Close bottom sheet first\r\n+                                          // Add url_launcher logic here if needed\r\n+                                      },\r\n+                                  ),\r\n+                           ],\r\n+                       ),\r\n                   ),\r\n-                  const SizedBox(height: 8),\r\n-                  if (timeCreated > 0)\r\n-                    Text(\r\n-                        'Received: ${_formatDateTime(timeCreated)}',\r\n-                        style: TextStyle(fontSize: 12, color: Colors.grey[700]),\r\n-                    ),\r\n-                  const Divider(height: 24),\r\n-                  if (notification['fullmessage'] != null && (notification['fullmessage'] as String).isNotEmpty)\r\n-                    Html(data: notification['fullmessage'] as String)\r\n-                  else\r\n-                    Text(smallMessage.isNotEmpty ? smallMessage : '(No details available)'), // Fallback\r\n-                  const SizedBox(height: 20),\r\n-                  // Context link button\r\n-                  if (notification['contexturl'] != null &&\r\n-                      (notification['contexturl'] as String).isNotEmpty &&\r\n-                      notification['contexturlname'] != null &&\r\n-                      (notification['contexturlname'] as String).isNotEmpty)\r\n-                    ElevatedButton.icon(\r\n-                      icon: const Icon(Icons.link),\r\n-                      label: Text('Go to: ${notification['contexturlname']}'),\r\n-                      onPressed: () {\r\n-                         // Use the new launch function\r\n-                         _launchContextUrl(notification['contexturl'] as String?, sheetContext);\r\n-                      },\r\n-                    ),\r\n-                ],\r\n-              ),\r\n-            ),\r\n-          ),\r\n-        );\r\n+             ),\r\n+         );\r\n \r\n-        // Mark as read (pass the index from the *filtered* list)\r\n-        if (!isRead && notification['id'] != null && notification['id'] != 0) {\r\n+\r\n+        // --- Mark as read ---\r\n+        if (!isRead && notification['id'] != null) {\r\n           _markAsRead(notification['id'] as int, index);\r\n         }\r\n       },\r\n     );\r\n@@ -350,45 +291,17 @@\n   @override\r\n   Widget build(BuildContext context) {\r\n     return Scaffold(\r\n       appBar: AppBar(\r\n-        // Show total unread count, not filtered count\r\n-        title: Text('Notifications ($_unreadCount unread)'),\r\n-        actions: [\r\n-          // Refresh Button\r\n-          IconButton(\r\n-            icon: const Icon(Icons.refresh),\r\n-            tooltip: 'Refresh Notifications',\r\n-            onPressed: _isLoading ? null : _fetchNotificationsUsingCoreMessages, // Or your preferred function\r\n-          ),\r\n-          // Filter Button\r\n-          PopupMenuButton<NotificationFilter>(\r\n-            tooltip: 'Filter Notifications',\r\n-            icon: const Icon(Icons.filter_list),\r\n-            onSelected: (NotificationFilter result) {\r\n-               if (_currentFilter != result) { // Only apply if filter changed\r\n-                   setState(() {\r\n-                      _currentFilter = result;\r\n-                   });\r\n-                   _applyFilter(); // Apply the new filter\r\n-               }\r\n-            },\r\n-            itemBuilder: (BuildContext context) => <PopupMenuEntry<NotificationFilter>>[\r\n-              const PopupMenuItem<NotificationFilter>(\r\n-                value: NotificationFilter.all,\r\n-                child: Text('Show All'),\r\n-              ),\r\n-              const PopupMenuItem<NotificationFilter>(\r\n-                value: NotificationFilter.unread,\r\n-                child: Text('Show Unread'),\r\n-              ),\r\n-              const PopupMenuItem<NotificationFilter>(\r\n-                value: NotificationFilter.read,\r\n-                child: Text('Show Read'),\r\n-              ),\r\n-            ],\r\n-          ),\r\n-        ],\r\n+         title: Text('Notifications ($_unreadCount unread)'),\r\n+         actions: [\r\n+             // Add a refresh button\r\n+             IconButton(\r\n+                 icon: const Icon(Icons.refresh),\r\n+                 tooltip: 'Refresh Notifications',\r\n+                 onPressed: _isLoading ? null : _fetchNotifications, // Disable while loading\r\n+             ),\r\n+         ],\r\n       ),\r\n       body: _buildBody(),\r\n     );\r\n   }\r\n@@ -398,10 +311,9 @@\n       return const Center(child: CircularProgressIndicator());\r\n     }\r\n \r\n     if (_error != null) {\r\n-      // ...(keep existing error display)...\r\n-        return Center(\r\n+      return Center(\r\n          child: Padding(\r\n            padding: const EdgeInsets.all(16.0),\r\n            child: Column(\r\n               mainAxisAlignment: MainAxisAlignment.center,\r\n@@ -414,59 +326,43 @@\n                  const SizedBox(height: 20),\r\n                  ElevatedButton.icon(\r\n                    icon: const Icon(Icons.refresh),\r\n                    label: const Text('Retry'),\r\n-                   onPressed: _fetchNotificationsUsingCoreMessages, // Or your preferred function\r\n+                   onPressed: _fetchInitialData, // Retry fetching everything including user ID if needed\r\n                  )\r\n               ],\r\n            ),\r\n          ),\r\n       );\r\n     }\r\n \r\n-    // Handle case where master list is empty vs filtered list is empty\r\n     if (_notifications.isEmpty) {\r\n       return Center(\r\n         child: Column(\r\n           mainAxisAlignment: MainAxisAlignment.center,\r\n           children: [\r\n-            const Icon(Icons.notifications_off_outlined, size: 60, color: Colors.grey),\r\n-            const SizedBox(height: 16),\r\n-            const Text('No notifications found.'),\r\n-            const SizedBox(height: 20),\r\n-            ElevatedButton.icon(\r\n-              icon: const Icon(Icons.refresh),\r\n-              label: const Text('Check Again'),\r\n-              onPressed: _fetchNotificationsUsingCoreMessages, // Or your preferred function\r\n-            )\r\n+              const Icon(Icons.notifications_off_outlined, size: 60, color: Colors.grey),\r\n+              const SizedBox(height: 16),\r\n+              const Text('No notifications found.'),\r\n+              const SizedBox(height: 20),\r\n+              ElevatedButton.icon(\r\n+                   icon: const Icon(Icons.refresh),\r\n+                   label: const Text('Check Again'),\r\n+                   onPressed: _fetchNotifications,\r\n+              )\r\n           ],\r\n         )\r\n       );\r\n     }\r\n \r\n-    // If master list is not empty, but filtered list is\r\n-    if (_filteredNotifications.isEmpty) {\r\n-        return Center(\r\n-          child: Column(\r\n-            mainAxisAlignment: MainAxisAlignment.center,\r\n-            children: [\r\n-              Icon(Icons.filter_alt_off_outlined, size: 60, color: Colors.grey),\r\n-              const SizedBox(height: 16),\r\n-              Text('No notifications match the \"${_currentFilter.name}\" filter.'), // Show current filter\r\n-            ],\r\n-          )\r\n-        );\r\n-    }\r\n-\r\n-\r\n-    // Use the filtered list here\r\n+    // Use RefreshIndicator for pull-to-refresh\r\n     return RefreshIndicator(\r\n-      onRefresh: _fetchNotificationsUsingCoreMessages, // Or your preferred function\r\n+      onRefresh: _fetchNotifications,\r\n       child: ListView.separated(\r\n-        itemCount: _filteredNotifications.length, // Use filtered list length\r\n-        separatorBuilder: (context, index) => const Divider(height: 1, indent: 72),\r\n+        itemCount: _notifications.length,\r\n+        separatorBuilder: (context, index) => const Divider(height: 1, indent: 72), // Add separators\r\n         itemBuilder: (context, index) =>\r\n-            _buildNotificationItem(_filteredNotifications[index], index), // Use filtered list item\r\n+            _buildNotificationItem(_notifications[index], index),\r\n       ),\r\n     );\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744993781490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,14 @@\n import 'dart:developer' as developer;\r\n import 'package:flutter_html/flutter_html.dart';\r\n import 'package:url_launcher/url_launcher.dart';\r\n \r\n+enum NotificationFilter {\r\n+  all,\r\n+  read,\r\n+  unread,\r\n+}\r\n+\r\n class NotificationsScreen extends StatefulWidget {\r\n   final String baseUrl;\r\n   final String token;\r\n \r\n"
                },
                {
                    "date": 1744993799621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,10 @@\n   int _unreadCount = 0; // Keep track of unread count\r\n   String? _error; // Store potential error messages\r\n   final ApiService _apiService = ApiService();\r\n   int? _userId; // Store user ID after fetching\r\n+  NotificationFilter _selectedFilter = NotificationFilter.all;\r\n+  List<Map<String, dynamic>> _filteredNotifications = [];\r\n \r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n"
                },
                {
                    "date": 1744993821474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,8 +151,28 @@\n           _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length); // Decrement unread count\r\n        }\r\n     });\r\n \r\n+    void _applyFilter() {\r\n+      setState(() {\r\n+        switch (_selectedFilter) {\r\n+          case NotificationFilter.all:\r\n+            _filteredNotifications = _notifications;\r\n+            break;\r\n+          case NotificationFilter.read:\r\n+            _filteredNotifications = _notifications\r\n+                .where((n) => n['timeread'] != null)\r\n+                .toList();\r\n+            break;\r\n+          case NotificationFilter.unread:\r\n+            _filteredNotifications = _notifications\r\n+                .where((n) => n['timeread'] == null)\r\n+                .toList();\r\n+            break;\r\n+        }\r\n+      });\r\n+    }\r\n+\r\n     // Call the API to mark as read\r\n     bool success = await _apiService.markNotificationRead(widget.baseUrl, widget.token, notificationId);\r\n \r\n     if (!success) {\r\n"
                },
                {
                    "date": 1744993859507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -392,5 +392,48 @@\n             _buildNotificationItem(_notifications[index], index),\r\n       ),\r\n     );\r\n   }\r\n+\r\n+  AppBar _buildAppBar() {\r\n+    return AppBar(\r\n+      title: Text('Notifications ($_unreadCount unread)'),\r\n+      actions: [\r\n+        Padding(\r\n+          padding: const EdgeInsets.only(right: 8.0),\r\n+          child: DropdownButton<NotificationFilter>(\r\n+            value: _selectedFilter,\r\n+            icon: const Icon(Icons.filter_list),\r\n+            underline: Container(),\r\n+            onChanged: (NotificationFilter? newValue) {\r\n+              if (newValue != null) {\r\n+                setState(() {\r\n+                  _selectedFilter = newValue;\r\n+                  _applyFilter();\r\n+                });\r\n+              }\r\n+            },\r\n+            items: const [\r\n+              DropdownMenuItem(\r\n+                value: NotificationFilter.all,\r\n+                child: Text('All'),\r\n+              ),\r\n+              DropdownMenuItem(\r\n+                value: NotificationFilter.unread,\r\n+                child: Text('Unread'),\r\n+              ),\r\n+              DropdownMenuItem(\r\n+                value: NotificationFilter.read,\r\n+                child: Text('Read'),\r\n+              ),\r\n+            ],\r\n+          ),\r\n+        ),\r\n+        IconButton(\r\n+          icon: const Icon(Icons.refresh),\r\n+          tooltip: 'Refresh Notifications',\r\n+          onPressed: _isLoading ? null : _fetchNotifications,\r\n+        ),\r\n+      ],\r\n+    );\r\n+  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744993881380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -318,19 +318,9 @@\n \r\n   @override\r\n   Widget build(BuildContext context) {\r\n     return Scaffold(\r\n-      appBar: AppBar(\r\n-         title: Text('Notifications ($_unreadCount unread)'),\r\n-         actions: [\r\n-             // Add a refresh button\r\n-             IconButton(\r\n-                 icon: const Icon(Icons.refresh),\r\n-                 tooltip: 'Refresh Notifications',\r\n-                 onPressed: _isLoading ? null : _fetchNotifications, // Disable while loading\r\n-             ),\r\n-         ],\r\n-      ),\r\n+      appBar: _buildAppBar(),\r\n       body: _buildBody(),\r\n     );\r\n   }\r\n \r\n"
                },
                {
                    "date": 1744993902307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,8 +39,9 @@\n   @override\r\n   void initState() {\r\n     super.initState();\r\n     _fetchInitialData();\r\n+    _applyFilter(); // Initial filter application\r\n   }\r\n \r\n   Future<void> _fetchInitialData() async {\r\n     // First, get the user ID if not already fetched elsewhere\r\n"
                },
                {
                    "date": 1744993928976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,9 +73,29 @@\n        await _fetchNotifications(); // User ID already available\r\n     }\r\n   }\r\n \r\n+  void _applyFilter() {\r\n+      setState(() {\r\n+        switch (_selectedFilter) {\r\n+          case NotificationFilter.all:\r\n+            _filteredNotifications = _notifications;\r\n+            break;\r\n+          case NotificationFilter.read:\r\n+            _filteredNotifications = _notifications\r\n+                .where((n) => n['timeread'] != null)\r\n+                .toList();\r\n+            break;\r\n+          case NotificationFilter.unread:\r\n+            _filteredNotifications = _notifications\r\n+                .where((n) => n['timeread'] == null)\r\n+                .toList();\r\n+            break;\r\n+        }\r\n+      });\r\n+    }\r\n \r\n+\r\n   Future<void> _fetchNotifications() async {\r\n     if (_userId == null) {\r\n        developer.log('Cannot fetch notifications: User ID is null.', name: 'NotificationsScreen', level: 1000);\r\n        setState(() {\r\n@@ -152,28 +172,8 @@\n           _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length); // Decrement unread count\r\n        }\r\n     });\r\n \r\n-    void _applyFilter() {\r\n-      setState(() {\r\n-        switch (_selectedFilter) {\r\n-          case NotificationFilter.all:\r\n-            _filteredNotifications = _notifications;\r\n-            break;\r\n-          case NotificationFilter.read:\r\n-            _filteredNotifications = _notifications\r\n-                .where((n) => n['timeread'] != null)\r\n-                .toList();\r\n-            break;\r\n-          case NotificationFilter.unread:\r\n-            _filteredNotifications = _notifications\r\n-                .where((n) => n['timeread'] == null)\r\n-                .toList();\r\n-            break;\r\n-        }\r\n-      });\r\n-    }\r\n-\r\n     // Call the API to mark as read\r\n     bool success = await _apiService.markNotificationRead(widget.baseUrl, widget.token, notificationId);\r\n \r\n     if (!success) {\r\n"
                },
                {
                    "date": 1744994014594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,56 +95,28 @@\n     }\r\n \r\n \r\n   Future<void> _fetchNotifications() async {\r\n-    if (_userId == null) {\r\n-       developer.log('Cannot fetch notifications: User ID is null.', name: 'NotificationsScreen', level: 1000);\r\n-       setState(() {\r\n-         _isLoading = false;\r\n-         _error = 'User ID not available.';\r\n-       });\r\n-       return;\r\n-    }\r\n+    if (_userId == null) return;\r\n \r\n     setState(() {\r\n       _isLoading = true;\r\n-      _error = null; // Clear previous errors\r\n+      _error = null;\r\n     });\r\n \r\n     try {\r\n-      developer.log('=== Starting notifications fetch ===', name: 'NotificationsScreen');\r\n-      developer.log('Base URL: ${widget.baseUrl}', name: 'NotificationsScreen');\r\n-      // Avoid logging token in production\r\n-      // developer.log('Token: ${widget.token}', name: 'NotificationsScreen');\r\n-      developer.log('User ID: $_userId', name: 'NotificationsScreen');\r\n-\r\n-      // Get notifications response (expecting a Map)\r\n-      final notificationsResponse = await _apiService.getNotifications(widget.baseUrl, widget.token, _userId!);\r\n-      developer.log('Raw notifications response map:', name: 'NotificationsScreen');\r\n-      developer.log(notificationsResponse.toString(), name: 'NotificationsScreen');\r\n-\r\n-      // Extract the list and unread count\r\n-      final List<dynamic> notificationsList = notificationsResponse['notifications'] as List<dynamic>? ?? [];\r\n+      final notificationsResponse = await _apiService.getNotifications(\r\n+          widget.baseUrl, widget.token, _userId!);\r\n+      final List<dynamic> notificationsList =\r\n+          notificationsResponse['notifications'] as List<dynamic>? ?? [];\r\n       final int unreadCount = notificationsResponse['unreadcount'] as int? ?? 0;\r\n \r\n-       // Ensure all items in the list are Maps\r\n-      final List<Map<String, dynamic>> typedNotifications = notificationsList\r\n-          .whereType<Map<String, dynamic>>() // Filter out non-map items if any\r\n-          .toList();\r\n-\r\n       setState(() {\r\n-        _notifications = typedNotifications;\r\n-        _unreadCount = unreadCount; // Update unread count\r\n+        _notifications = notificationsList.whereType<Map<String, dynamic>>().toList();\r\n+        _unreadCount = unreadCount;\r\n         _isLoading = false;\r\n+        _applyFilter(); // Apply filter after new data loads\r\n       });\r\n-\r\n-      developer.log('\\n=== Processed notifications data ===', name: 'NotificationsScreen');\r\n-      developer.log('Number of notifications: ${_notifications.length}', name: 'NotificationsScreen');\r\n-      developer.log('Reported unread count: $_unreadCount', name: 'NotificationsScreen');\r\n-      if (_notifications.isNotEmpty) {\r\n-        developer.log('First notification details:', name: 'NotificationsScreen');\r\n-        developer.log(_notifications.first.toString(), name: 'NotificationsScreen');\r\n-      }\r\n     } catch (e, s) {\r\n       developer.log('\\n=== Error occurred fetching notifications ===', name: 'NotificationsScreen', error: e, stackTrace: s, level: 1000);\r\n       if (e is DioException) {\r\n         developer.log('Dio error details:', name: 'NotificationsScreen', level: 1000);\r\n@@ -330,29 +302,17 @@\n       return const Center(child: CircularProgressIndicator());\r\n     }\r\n \r\n     if (_error != null) {\r\n-      return Center(\r\n-         child: Padding(\r\n-           padding: const EdgeInsets.all(16.0),\r\n-           child: Column(\r\n-              mainAxisAlignment: MainAxisAlignment.center,\r\n-              children: [\r\n-                 const Icon(Icons.error_outline, color: Colors.red, size: 48),\r\n-                 const SizedBox(height: 16),\r\n-                 Text('Error loading notifications:', textAlign: TextAlign.center, style: Theme.of(context).textTheme.titleMedium),\r\n-                 const SizedBox(height: 8),\r\n-                 Text(_error!, textAlign: TextAlign.center, style: TextStyle(color: Colors.grey[700])),\r\n-                 const SizedBox(height: 20),\r\n-                 ElevatedButton.icon(\r\n-                   icon: const Icon(Icons.refresh),\r\n-                   label: const Text('Retry'),\r\n-                   onPressed: _fetchInitialData, // Retry fetching everything including user ID if needed\r\n-                 )\r\n-              ],\r\n-           ),\r\n-         ),\r\n-      );\r\n+      return RefreshIndicator(\r\n+      onRefresh: _fetchNotifications,\r\n+      child: ListView.separated(\r\n+        itemCount: _filteredNotifications.length,\r\n+        separatorBuilder: (context, index) => const Divider(height: 1, indent: 72),\r\n+        itemBuilder: (context, index) =>\r\n+            _buildNotificationItem(_filteredNotifications[index], index),\r\n+      ),\r\n+    );\r\n     }\r\n \r\n     if (_notifications.isEmpty) {\r\n       return Center(\r\n"
                },
                {
                    "date": 1744994037043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,8 +168,9 @@\n     } else {\r\n        developer.log('Successfully marked notification $notificationId as read on server.', name: 'NotificationsScreen');\r\n        // UI is already updated, maybe refresh the count from API if needed\r\n     }\r\n+    _applyFilter();\r\n   }\r\n \r\n   // Helper to format the date/time nicely\r\n   String _formatDateTime(int timestamp) {\r\n"
                },
                {
                    "date": 1744994087333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+import 'package:aybudle/core/constants/app_constants.dart';\r\n import 'package:dio/dio.dart';\r\n import 'package:flutter/material.dart';\r\n import 'package:aybudle/core/services/api_service.dart';\r\n import 'dart:developer' as developer;\r\n@@ -366,17 +367,17 @@\n             },\r\n             items: const [\r\n               DropdownMenuItem(\r\n                 value: NotificationFilter.all,\r\n-                child: Text('All'),\r\n+                child: Text(AppConstants.filterAll),\r\n               ),\r\n               DropdownMenuItem(\r\n                 value: NotificationFilter.unread,\r\n-                child: Text('Unread'),\r\n+                child: Text(AppConstants.filterUnread),\r\n               ),\r\n               DropdownMenuItem(\r\n                 value: NotificationFilter.read,\r\n-                child: Text('Read'),\r\n+                child: Text(AppConstants.filterRead),\r\n               ),\r\n             ],\r\n           ),\r\n         ),\r\n"
                },
                {
                    "date": 1744994266672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,46 +132,40 @@\n   }\r\n \r\n   // Function to mark a notification as read\r\n   Future<void> _markAsRead(int notificationId, int index) async {\r\n-    // Optimistically update the UI first\r\n+    // Optimistic UI update\r\n     setState(() {\r\n-      // Find the notification and update its timeread locally\r\n-      // Create a mutable copy if needed\r\n-      // Note: This assumes 'timeread' is the field indicating read status. Adjust if needed.\r\n-       var updatedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n-       if (updatedNotification['timeread'] == null) {\r\n-          updatedNotification['timeread'] = DateTime.now().millisecondsSinceEpoch ~/ 1000;\r\n-          _notifications[index] = updatedNotification;\r\n-          _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length); // Decrement unread count\r\n-       }\r\n+      var updatedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n+      updatedNotification['timeread'] = DateTime.now().millisecondsSinceEpoch ~/ 1000;\r\n+      _notifications[index] = updatedNotification;\r\n+      _unreadCount = (_unreadCount - 1).clamp(0, _notifications.length);\r\n+      _applyFilter();\r\n     });\r\n \r\n-    // Call the API to mark as read\r\n-    bool success = await _apiService.markNotificationRead(widget.baseUrl, widget.token, notificationId);\r\n+    bool success = await _apiService.markNotificationRead(\r\n+      widget.baseUrl,\r\n+      widget.token,\r\n+      notificationId,\r\n+    );\r\n \r\n     if (!success) {\r\n-      developer.log('Failed to mark notification $notificationId as read on server.', name: 'NotificationsScreen', level: 900); // Log as warning\r\n-      // Optionally revert the UI change or show a snackbar\r\n-       ScaffoldMessenger.of(context).showSnackBar(\r\n-          const SnackBar(content: Text('Could not mark notification as read on server.')),\r\n-       );\r\n-       // Revert UI change (optional, might cause flicker)\r\n-       /* setState(() {\r\n-          var revertedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n-           if (revertedNotification['timeread'] != null) { // Check if it was actually changed\r\n-              revertedNotification['timeread'] = null;\r\n-              _notifications[index] = revertedNotification;\r\n-              _unreadCount++; // Increment back\r\n-           }\r\n-       }); */\r\n-       // Or just refresh the list entirely to get the true state\r\n-       // await _fetchNotifications();\r\n+      // If failed, revert UI and show error\r\n+      setState(() {\r\n+        var revertedNotification = Map<String, dynamic>.from(_notifications[index]);\r\n+        revertedNotification['timeread'] = null;\r\n+        _notifications[index] = revertedNotification;\r\n+        _unreadCount = (_unreadCount + 1).clamp(0, _notifications.length);\r\n+        _applyFilter();\r\n+      });\r\n+      \r\n+      ScaffoldMessenger.of(context).showSnackBar(\r\n+        const SnackBar(content: Text('Failed to mark notification as read')),\r\n+      );\r\n     } else {\r\n-       developer.log('Successfully marked notification $notificationId as read on server.', name: 'NotificationsScreen');\r\n-       // UI is already updated, maybe refresh the count from API if needed\r\n+      // Force refresh from server to confirm\r\n+      await _fetchNotifications();\r\n     }\r\n-    _applyFilter();\r\n   }\r\n \r\n   // Helper to format the date/time nicely\r\n   String _formatDateTime(int timestamp) {\r\n"
                },
                {
                    "date": 1744994391774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,11 +157,9 @@\n         _unreadCount = (_unreadCount + 1).clamp(0, _notifications.length);\r\n         _applyFilter();\r\n       });\r\n       \r\n-      ScaffoldMessenger.of(context).showSnackBar(\r\n-        const SnackBar(content: Text('Failed to mark notification as read')),\r\n-      );\r\n+      await _fetchNotifications();\r\n     } else {\r\n       // Force refresh from server to confirm\r\n       await _fetchNotifications();\r\n     }\r\n"
                }
            ],
            "date": 1742921167428,
            "name": "Commit-0",
            "content": "import 'package:flutter/material.dart';\r\nimport 'package:aybudle/core/services/api_service.dart';\r\n\r\nclass NotificationsScreen extends StatefulWidget {\r\n  final String baseUrl;\r\n  final String token;\r\n\r\n  const NotificationsScreen({\r\n    Key? key,\r\n    required this.baseUrl,\r\n    required this.token,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  State<NotificationsScreen> createState() => _NotificationsScreenState();\r\n}\r\n\r\nclass _NotificationsScreenState extends State<NotificationsScreen> {\r\n  bool _isLoading = true;\r\n  List<dynamic> _notifications = [];\r\n  final ApiService _apiService = ApiService();\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _fetchNotifications();\r\n  }\r\n\r\n  Future<void> _fetchNotifications() async {\r\n    try {\r\n      final userInfo = await _apiService.getUserInfo(widget.baseUrl, widget.token);\r\n      final userId = userInfo['userid'] as int;\r\n      final notifications = await _apiService.getNotifications(widget.baseUrl, widget.token, userId);\r\n\r\n      setState(() {\r\n        _notifications = notifications;\r\n        _isLoading = false;\r\n      });\r\n    } catch (e) {\r\n      print('Error fetching notifications: $e');\r\n      setState(() => _isLoading = false);\r\n    }\r\n  }\r\n\r\n  Widget _buildNotificationItem(Map<String, dynamic> notification) {\r\n    return ListTile(\r\n      title: Text(notification['subject'] ?? 'No Subject'),\r\n      subtitle: Text(notification['smallmessage'] ?? 'No message'),\r\n      trailing: notification['timecreated'] != null\r\n          ? Text(DateTime.fromMillisecondsSinceEpoch(\r\n                  notification['timecreated'] * 1000)\r\n              .toString()\r\n              .split(' ')\r\n              .first)\r\n          : const Text(''),\r\n    );\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Scaffold(\r\n      appBar: AppBar(title: const Text('Notifications')),\r\n      body: _isLoading\r\n          ? const Center(child: CircularProgressIndicator())\r\n          : _notifications.isEmpty\r\n              ? const Center(child: Text('No notifications found.'))\r\n              : ListView.builder(\r\n                  itemCount: _notifications.length,\r\n                  itemBuilder: (context, index) =>\r\n                      _buildNotificationItem(_notifications[index]),\r\n                ),\r\n    );\r\n  }\r\n}"
        }
    ]
}